<?php
namespace EMQ\Queue;

/**
 * Autogenerated by Thrift Compiler (0.9.2)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
use Thrift\Base\TBase;
use Thrift\Type\TType;
use Thrift\Type\TMessageType;
use Thrift\Exception\TException;
use Thrift\Exception\TProtocolException;
use Thrift\Protocol\TProtocol;
use Thrift\Protocol\TBinaryProtocolAccelerated;
use Thrift\Exception\TApplicationException;


final class Permission {
  const NONE = 0;
  const SEND_MESSAGE = 1;
  const RECEIVE_MESSAGE = 2;
  const SEND_RECEIVE_MESSAGE = 3;
  const HANDLE_MESSAGE = 4;
  const SEND_HANDLE_MESSAGE = 5;
  const GET_QUEUE_INFO = 6;
  const USE_QUEUE = 7;
  const ADMIN_QUEUE = 8;
  const FULL_CONTROL = 9;
  static public $__names = array(
    0 => 'NONE',
    1 => 'SEND_MESSAGE',
    2 => 'RECEIVE_MESSAGE',
    3 => 'SEND_RECEIVE_MESSAGE',
    4 => 'HANDLE_MESSAGE',
    5 => 'SEND_HANDLE_MESSAGE',
    6 => 'GET_QUEUE_INFO',
    7 => 'USE_QUEUE',
    8 => 'ADMIN_QUEUE',
    9 => 'FULL_CONTROL',
  );
}

/**
 * Copyright 2015, Xiaomi.
 * All rights reserved.
 * Author: shenyuannan@xiaomi.com
 */
class QueueAttribute {
  static $_TSPEC;

  /**
   * Queue delay seconds, message send to this queue will invisible until after
   * delaySeconds, default 0s (0s ~ 15min)
   * 
   * 
   * @var int
   */
  public $delaySeconds = null;
  /**
   * Queue invisibility seconds, after message received form this queue, in
   * invisibilitySeconds this will not received through receiveMessage. When
   * after invisibilitySeconds if no deleteMessage called for this message, this
   * message will receive again, default 30s (2s ~ 12hour)
   * 
   * 
   * @var int
   */
  public $invisibilitySeconds = null;
  /**
   * The seconds wait when receiveMessage called, default 0s (0s ~ 20s)
   * 
   * 
   * @var int
   */
  public $receiveMessageWaitSeconds = null;
  /**
   * Maximum receive message number in this queue, default 100(1 ~ 100)
   * 
   * 
   * @var int
   */
  public $receiveMessageMaximumNumber = null;
  /**
   * message retention seconds in this queue, default 4days (60s ~ 14days)
   * 
   * 
   * @var int
   */
  public $messageRetentionSeconds = null;
  /**
   * Max message size in this queue, default 256K (1K ~ 256K)
   * 
   * 
   * @var int
   */
  public $messageMaximumBytes = null;
  /**
   * Partition number for this queue default 4 (1 ~ 255)
   * 
   * 
   * @var int
   */
  public $partitionNumber = null;
  /**
   * User-defined attributes;
   * 
   * 
   * @var array
   */
  public $userAttributes = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'delaySeconds',
          'type' => TType::I32,
          ),
        2 => array(
          'var' => 'invisibilitySeconds',
          'type' => TType::I32,
          ),
        3 => array(
          'var' => 'receiveMessageWaitSeconds',
          'type' => TType::I32,
          ),
        4 => array(
          'var' => 'receiveMessageMaximumNumber',
          'type' => TType::I32,
          ),
        5 => array(
          'var' => 'messageRetentionSeconds',
          'type' => TType::I32,
          ),
        6 => array(
          'var' => 'messageMaximumBytes',
          'type' => TType::I32,
          ),
        7 => array(
          'var' => 'partitionNumber',
          'type' => TType::I32,
          ),
        8 => array(
          'var' => 'userAttributes',
          'type' => TType::MAP,
          'ktype' => TType::STRING,
          'vtype' => TType::STRING,
          'key' => array(
            'type' => TType::STRING,
          ),
          'val' => array(
            'type' => TType::STRING,
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['delaySeconds'])) {
        $this->delaySeconds = $vals['delaySeconds'];
      }
      if (isset($vals['invisibilitySeconds'])) {
        $this->invisibilitySeconds = $vals['invisibilitySeconds'];
      }
      if (isset($vals['receiveMessageWaitSeconds'])) {
        $this->receiveMessageWaitSeconds = $vals['receiveMessageWaitSeconds'];
      }
      if (isset($vals['receiveMessageMaximumNumber'])) {
        $this->receiveMessageMaximumNumber = $vals['receiveMessageMaximumNumber'];
      }
      if (isset($vals['messageRetentionSeconds'])) {
        $this->messageRetentionSeconds = $vals['messageRetentionSeconds'];
      }
      if (isset($vals['messageMaximumBytes'])) {
        $this->messageMaximumBytes = $vals['messageMaximumBytes'];
      }
      if (isset($vals['partitionNumber'])) {
        $this->partitionNumber = $vals['partitionNumber'];
      }
      if (isset($vals['userAttributes'])) {
        $this->userAttributes = $vals['userAttributes'];
      }
    }
  }

  public function getName() {
    return 'QueueAttribute';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->delaySeconds);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->invisibilitySeconds);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->receiveMessageWaitSeconds);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->receiveMessageMaximumNumber);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->messageRetentionSeconds);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->messageMaximumBytes);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 7:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->partitionNumber);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 8:
          if ($ftype == TType::MAP) {
            $this->userAttributes = array();
            $_size0 = 0;
            $_ktype1 = 0;
            $_vtype2 = 0;
            $xfer += $input->readMapBegin($_ktype1, $_vtype2, $_size0);
            for ($_i4 = 0; $_i4 < $_size0; ++$_i4)
            {
              $key5 = '';
              $val6 = '';
              $xfer += $input->readString($key5);
              $xfer += $input->readString($val6);
              $this->userAttributes[$key5] = $val6;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('QueueAttribute');
    if ($this->delaySeconds !== null) {
      $xfer += $output->writeFieldBegin('delaySeconds', TType::I32, 1);
      $xfer += $output->writeI32($this->delaySeconds);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->invisibilitySeconds !== null) {
      $xfer += $output->writeFieldBegin('invisibilitySeconds', TType::I32, 2);
      $xfer += $output->writeI32($this->invisibilitySeconds);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->receiveMessageWaitSeconds !== null) {
      $xfer += $output->writeFieldBegin('receiveMessageWaitSeconds', TType::I32, 3);
      $xfer += $output->writeI32($this->receiveMessageWaitSeconds);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->receiveMessageMaximumNumber !== null) {
      $xfer += $output->writeFieldBegin('receiveMessageMaximumNumber', TType::I32, 4);
      $xfer += $output->writeI32($this->receiveMessageMaximumNumber);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->messageRetentionSeconds !== null) {
      $xfer += $output->writeFieldBegin('messageRetentionSeconds', TType::I32, 5);
      $xfer += $output->writeI32($this->messageRetentionSeconds);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->messageMaximumBytes !== null) {
      $xfer += $output->writeFieldBegin('messageMaximumBytes', TType::I32, 6);
      $xfer += $output->writeI32($this->messageMaximumBytes);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->partitionNumber !== null) {
      $xfer += $output->writeFieldBegin('partitionNumber', TType::I32, 7);
      $xfer += $output->writeI32($this->partitionNumber);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->userAttributes !== null) {
      if (!is_array($this->userAttributes)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('userAttributes', TType::MAP, 8);
      {
        $output->writeMapBegin(TType::STRING, TType::STRING, count($this->userAttributes));
        {
          foreach ($this->userAttributes as $kiter7 => $viter8)
          {
            $xfer += $output->writeString($kiter7);
            $xfer += $output->writeString($viter8);
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class QueueState {
  static $_TSPEC;

  /**
   * Queue create timestamp;
   * 
   * 
   * @var int
   */
  public $createTimestamp = null;
  /**
   * Queue last modified timestamp;
   * 
   * 
   * @var int
   */
  public $lastModifiedTimestamp = null;
  /**
   * The approximate message number in this queue;
   * 
   * 
   * @var int
   */
  public $approximateMessageNumber = null;
  /**
   * The available message number in this queue, this is for message that could
   * be get using receivedMessage
   * 
   * 
   * @var int
   */
  public $approximateAvailableMessageNumber = null;
  /**
   * The invisibility message number in this queue, this is for received message
   * that in invisibilitySeconds and not deleted;
   * 
   * 
   * @var int
   */
  public $approximateInvisibilityMessageNumber = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'createTimestamp',
          'type' => TType::I64,
          ),
        2 => array(
          'var' => 'lastModifiedTimestamp',
          'type' => TType::I64,
          ),
        3 => array(
          'var' => 'approximateMessageNumber',
          'type' => TType::I64,
          ),
        4 => array(
          'var' => 'approximateAvailableMessageNumber',
          'type' => TType::I64,
          ),
        5 => array(
          'var' => 'approximateInvisibilityMessageNumber',
          'type' => TType::I64,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['createTimestamp'])) {
        $this->createTimestamp = $vals['createTimestamp'];
      }
      if (isset($vals['lastModifiedTimestamp'])) {
        $this->lastModifiedTimestamp = $vals['lastModifiedTimestamp'];
      }
      if (isset($vals['approximateMessageNumber'])) {
        $this->approximateMessageNumber = $vals['approximateMessageNumber'];
      }
      if (isset($vals['approximateAvailableMessageNumber'])) {
        $this->approximateAvailableMessageNumber = $vals['approximateAvailableMessageNumber'];
      }
      if (isset($vals['approximateInvisibilityMessageNumber'])) {
        $this->approximateInvisibilityMessageNumber = $vals['approximateInvisibilityMessageNumber'];
      }
    }
  }

  public function getName() {
    return 'QueueState';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->createTimestamp);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->lastModifiedTimestamp);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->approximateMessageNumber);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->approximateAvailableMessageNumber);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->approximateInvisibilityMessageNumber);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('QueueState');
    if ($this->createTimestamp !== null) {
      $xfer += $output->writeFieldBegin('createTimestamp', TType::I64, 1);
      $xfer += $output->writeI64($this->createTimestamp);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->lastModifiedTimestamp !== null) {
      $xfer += $output->writeFieldBegin('lastModifiedTimestamp', TType::I64, 2);
      $xfer += $output->writeI64($this->lastModifiedTimestamp);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->approximateMessageNumber !== null) {
      $xfer += $output->writeFieldBegin('approximateMessageNumber', TType::I64, 3);
      $xfer += $output->writeI64($this->approximateMessageNumber);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->approximateAvailableMessageNumber !== null) {
      $xfer += $output->writeFieldBegin('approximateAvailableMessageNumber', TType::I64, 4);
      $xfer += $output->writeI64($this->approximateAvailableMessageNumber);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->approximateInvisibilityMessageNumber !== null) {
      $xfer += $output->writeFieldBegin('approximateInvisibilityMessageNumber', TType::I64, 5);
      $xfer += $output->writeI64($this->approximateInvisibilityMessageNumber);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Throughput {
  static $_TSPEC;

  /**
   * Queue read qps;
   * 
   * 
   * @var int
   */
  public $readQps = null;
  /**
   * Queue write qps;
   * 
   * 
   * @var int
   */
  public $writeQps = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'readQps',
          'type' => TType::I64,
          ),
        2 => array(
          'var' => 'writeQps',
          'type' => TType::I64,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['readQps'])) {
        $this->readQps = $vals['readQps'];
      }
      if (isset($vals['writeQps'])) {
        $this->writeQps = $vals['writeQps'];
      }
    }
  }

  public function getName() {
    return 'Throughput';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->readQps);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->writeQps);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Throughput');
    if ($this->readQps !== null) {
      $xfer += $output->writeFieldBegin('readQps', TType::I64, 1);
      $xfer += $output->writeI64($this->readQps);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->writeQps !== null) {
      $xfer += $output->writeFieldBegin('writeQps', TType::I64, 2);
      $xfer += $output->writeI64($this->writeQps);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class QueueQuota {
  static $_TSPEC;

  /**
   * Queue read and qps;
   * 
   * 
   * @var \EMQ\Queue\Throughput
   */
  public $throughput = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        2 => array(
          'var' => 'throughput',
          'type' => TType::STRUCT,
          'class' => '\EMQ\Queue\Throughput',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['throughput'])) {
        $this->throughput = $vals['throughput'];
      }
    }
  }

  public function getName() {
    return 'QueueQuota';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->throughput = new \EMQ\Queue\Throughput();
            $xfer += $this->throughput->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('QueueQuota');
    if ($this->throughput !== null) {
      if (!is_object($this->throughput)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('throughput', TType::STRUCT, 2);
      $xfer += $this->throughput->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class CreateQueueRequest {
  static $_TSPEC;

  /**
   * The queue name;
   * 
   * 
   * @var string
   */
  public $queueName = null;
  /**
   * The queue attribute;
   * 
   * 
   * @var \EMQ\Queue\QueueAttribute
   */
  public $queueAttribute = null;
  /**
   * The queue quota, including space quota, read qps, and write qps;
   * 
   * 
   * @var \EMQ\Queue\QueueQuota
   */
  public $queueQuota = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'queueName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'queueAttribute',
          'type' => TType::STRUCT,
          'class' => '\EMQ\Queue\QueueAttribute',
          ),
        3 => array(
          'var' => 'queueQuota',
          'type' => TType::STRUCT,
          'class' => '\EMQ\Queue\QueueQuota',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['queueName'])) {
        $this->queueName = $vals['queueName'];
      }
      if (isset($vals['queueAttribute'])) {
        $this->queueAttribute = $vals['queueAttribute'];
      }
      if (isset($vals['queueQuota'])) {
        $this->queueQuota = $vals['queueQuota'];
      }
    }
  }

  public function getName() {
    return 'CreateQueueRequest';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->queueName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->queueAttribute = new \EMQ\Queue\QueueAttribute();
            $xfer += $this->queueAttribute->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->queueQuota = new \EMQ\Queue\QueueQuota();
            $xfer += $this->queueQuota->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('CreateQueueRequest');
    if ($this->queueName !== null) {
      $xfer += $output->writeFieldBegin('queueName', TType::STRING, 1);
      $xfer += $output->writeString($this->queueName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->queueAttribute !== null) {
      if (!is_object($this->queueAttribute)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('queueAttribute', TType::STRUCT, 2);
      $xfer += $this->queueAttribute->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->queueQuota !== null) {
      if (!is_object($this->queueQuota)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('queueQuota', TType::STRUCT, 3);
      $xfer += $this->queueQuota->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class CreateQueueResponse {
  static $_TSPEC;

  /**
   * The queue name;
   * The name returned here may be a little different from user set in request (with developerId as prefix).
   * So the user should use the name returned by this response for those following operations
   * 
   * 
   * @var string
   */
  public $queueName = null;
  /**
   * The queue attribute;
   * 
   * 
   * @var \EMQ\Queue\QueueAttribute
   */
  public $queueAttribute = null;
  /**
   * The queue quota;
   * 
   * 
   * @var \EMQ\Queue\QueueQuota
   */
  public $queueQuota = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'queueName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'queueAttribute',
          'type' => TType::STRUCT,
          'class' => '\EMQ\Queue\QueueAttribute',
          ),
        3 => array(
          'var' => 'queueQuota',
          'type' => TType::STRUCT,
          'class' => '\EMQ\Queue\QueueQuota',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['queueName'])) {
        $this->queueName = $vals['queueName'];
      }
      if (isset($vals['queueAttribute'])) {
        $this->queueAttribute = $vals['queueAttribute'];
      }
      if (isset($vals['queueQuota'])) {
        $this->queueQuota = $vals['queueQuota'];
      }
    }
  }

  public function getName() {
    return 'CreateQueueResponse';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->queueName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->queueAttribute = new \EMQ\Queue\QueueAttribute();
            $xfer += $this->queueAttribute->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->queueQuota = new \EMQ\Queue\QueueQuota();
            $xfer += $this->queueQuota->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('CreateQueueResponse');
    if ($this->queueName !== null) {
      $xfer += $output->writeFieldBegin('queueName', TType::STRING, 1);
      $xfer += $output->writeString($this->queueName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->queueAttribute !== null) {
      if (!is_object($this->queueAttribute)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('queueAttribute', TType::STRUCT, 2);
      $xfer += $this->queueAttribute->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->queueQuota !== null) {
      if (!is_object($this->queueQuota)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('queueQuota', TType::STRUCT, 3);
      $xfer += $this->queueQuota->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class DeleteQueueRequest {
  static $_TSPEC;

  /**
   * The queue name;
   * 
   * 
   * @var string
   */
  public $queueName = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'queueName',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['queueName'])) {
        $this->queueName = $vals['queueName'];
      }
    }
  }

  public function getName() {
    return 'DeleteQueueRequest';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->queueName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('DeleteQueueRequest');
    if ($this->queueName !== null) {
      $xfer += $output->writeFieldBegin('queueName', TType::STRING, 1);
      $xfer += $output->writeString($this->queueName);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class PurgeQueueRequest {
  static $_TSPEC;

  /**
   * The queue name;
   * 
   * 
   * @var string
   */
  public $queueName = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'queueName',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['queueName'])) {
        $this->queueName = $vals['queueName'];
      }
    }
  }

  public function getName() {
    return 'PurgeQueueRequest';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->queueName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('PurgeQueueRequest');
    if ($this->queueName !== null) {
      $xfer += $output->writeFieldBegin('queueName', TType::STRING, 1);
      $xfer += $output->writeString($this->queueName);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class SetQueueAttributesRequest {
  static $_TSPEC;

  /**
   * The queue name;
   * 
   * 
   * @var string
   */
  public $queueName = null;
  /**
   * The queue attribute;
   * 
   * 
   * @var \EMQ\Queue\QueueAttribute
   */
  public $queueAttribute = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'queueName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'queueAttribute',
          'type' => TType::STRUCT,
          'class' => '\EMQ\Queue\QueueAttribute',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['queueName'])) {
        $this->queueName = $vals['queueName'];
      }
      if (isset($vals['queueAttribute'])) {
        $this->queueAttribute = $vals['queueAttribute'];
      }
    }
  }

  public function getName() {
    return 'SetQueueAttributesRequest';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->queueName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->queueAttribute = new \EMQ\Queue\QueueAttribute();
            $xfer += $this->queueAttribute->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('SetQueueAttributesRequest');
    if ($this->queueName !== null) {
      $xfer += $output->writeFieldBegin('queueName', TType::STRING, 1);
      $xfer += $output->writeString($this->queueName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->queueAttribute !== null) {
      if (!is_object($this->queueAttribute)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('queueAttribute', TType::STRUCT, 2);
      $xfer += $this->queueAttribute->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class SetQueueAttributesResponse {
  static $_TSPEC;

  /**
   * The queue name;
   * 
   * 
   * @var string
   */
  public $queueName = null;
  /**
   * The queue attribute;
   * 
   * 
   * @var \EMQ\Queue\QueueAttribute
   */
  public $queueAttribute = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'queueName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'queueAttribute',
          'type' => TType::STRUCT,
          'class' => '\EMQ\Queue\QueueAttribute',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['queueName'])) {
        $this->queueName = $vals['queueName'];
      }
      if (isset($vals['queueAttribute'])) {
        $this->queueAttribute = $vals['queueAttribute'];
      }
    }
  }

  public function getName() {
    return 'SetQueueAttributesResponse';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->queueName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->queueAttribute = new \EMQ\Queue\QueueAttribute();
            $xfer += $this->queueAttribute->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('SetQueueAttributesResponse');
    if ($this->queueName !== null) {
      $xfer += $output->writeFieldBegin('queueName', TType::STRING, 1);
      $xfer += $output->writeString($this->queueName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->queueAttribute !== null) {
      if (!is_object($this->queueAttribute)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('queueAttribute', TType::STRUCT, 2);
      $xfer += $this->queueAttribute->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class SetQueueQuotaRequest {
  static $_TSPEC;

  /**
   * The queue name;
   * 
   * 
   * @var string
   */
  public $queueName = null;
  /**
   * The queue quota;
   * 
   * 
   * @var \EMQ\Queue\QueueQuota
   */
  public $queueQuota = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'queueName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'queueQuota',
          'type' => TType::STRUCT,
          'class' => '\EMQ\Queue\QueueQuota',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['queueName'])) {
        $this->queueName = $vals['queueName'];
      }
      if (isset($vals['queueQuota'])) {
        $this->queueQuota = $vals['queueQuota'];
      }
    }
  }

  public function getName() {
    return 'SetQueueQuotaRequest';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->queueName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->queueQuota = new \EMQ\Queue\QueueQuota();
            $xfer += $this->queueQuota->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('SetQueueQuotaRequest');
    if ($this->queueName !== null) {
      $xfer += $output->writeFieldBegin('queueName', TType::STRING, 1);
      $xfer += $output->writeString($this->queueName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->queueQuota !== null) {
      if (!is_object($this->queueQuota)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('queueQuota', TType::STRUCT, 2);
      $xfer += $this->queueQuota->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class SetQueueQuotaResponse {
  static $_TSPEC;

  /**
   * The queue name;
   * 
   * 
   * @var string
   */
  public $queueName = null;
  /**
   * The queue quota;
   * 
   * 
   * @var \EMQ\Queue\QueueQuota
   */
  public $queueQuota = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'queueName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'queueQuota',
          'type' => TType::STRUCT,
          'class' => '\EMQ\Queue\QueueQuota',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['queueName'])) {
        $this->queueName = $vals['queueName'];
      }
      if (isset($vals['queueQuota'])) {
        $this->queueQuota = $vals['queueQuota'];
      }
    }
  }

  public function getName() {
    return 'SetQueueQuotaResponse';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->queueName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->queueQuota = new \EMQ\Queue\QueueQuota();
            $xfer += $this->queueQuota->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('SetQueueQuotaResponse');
    if ($this->queueName !== null) {
      $xfer += $output->writeFieldBegin('queueName', TType::STRING, 1);
      $xfer += $output->writeString($this->queueName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->queueQuota !== null) {
      if (!is_object($this->queueQuota)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('queueQuota', TType::STRUCT, 2);
      $xfer += $this->queueQuota->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class GetQueueInfoRequest {
  static $_TSPEC;

  /**
   * The queue name;
   * 
   * 
   * @var string
   */
  public $queueName = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'queueName',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['queueName'])) {
        $this->queueName = $vals['queueName'];
      }
    }
  }

  public function getName() {
    return 'GetQueueInfoRequest';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->queueName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('GetQueueInfoRequest');
    if ($this->queueName !== null) {
      $xfer += $output->writeFieldBegin('queueName', TType::STRING, 1);
      $xfer += $output->writeString($this->queueName);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class GetQueueInfoResponse {
  static $_TSPEC;

  /**
   * The queue name;
   * 
   * 
   * @var string
   */
  public $queueName = null;
  /**
   * The queue attribute;
   * 
   * 
   * @var \EMQ\Queue\QueueAttribute
   */
  public $queueAttribute = null;
  /**
   * The queue state;
   * 
   * 
   * @var \EMQ\Queue\QueueState
   */
  public $queueState = null;
  /**
   * The queue quota;
   * 
   * 
   * @var \EMQ\Queue\QueueQuota
   */
  public $queueQuota = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'queueName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'queueAttribute',
          'type' => TType::STRUCT,
          'class' => '\EMQ\Queue\QueueAttribute',
          ),
        3 => array(
          'var' => 'queueState',
          'type' => TType::STRUCT,
          'class' => '\EMQ\Queue\QueueState',
          ),
        4 => array(
          'var' => 'queueQuota',
          'type' => TType::STRUCT,
          'class' => '\EMQ\Queue\QueueQuota',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['queueName'])) {
        $this->queueName = $vals['queueName'];
      }
      if (isset($vals['queueAttribute'])) {
        $this->queueAttribute = $vals['queueAttribute'];
      }
      if (isset($vals['queueState'])) {
        $this->queueState = $vals['queueState'];
      }
      if (isset($vals['queueQuota'])) {
        $this->queueQuota = $vals['queueQuota'];
      }
    }
  }

  public function getName() {
    return 'GetQueueInfoResponse';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->queueName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->queueAttribute = new \EMQ\Queue\QueueAttribute();
            $xfer += $this->queueAttribute->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->queueState = new \EMQ\Queue\QueueState();
            $xfer += $this->queueState->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRUCT) {
            $this->queueQuota = new \EMQ\Queue\QueueQuota();
            $xfer += $this->queueQuota->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('GetQueueInfoResponse');
    if ($this->queueName !== null) {
      $xfer += $output->writeFieldBegin('queueName', TType::STRING, 1);
      $xfer += $output->writeString($this->queueName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->queueAttribute !== null) {
      if (!is_object($this->queueAttribute)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('queueAttribute', TType::STRUCT, 2);
      $xfer += $this->queueAttribute->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->queueState !== null) {
      if (!is_object($this->queueState)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('queueState', TType::STRUCT, 3);
      $xfer += $this->queueState->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->queueQuota !== null) {
      if (!is_object($this->queueQuota)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('queueQuota', TType::STRUCT, 4);
      $xfer += $this->queueQuota->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ListQueueRequest {
  static $_TSPEC;

  /**
   * The queue name prefix;
   * 
   * 
   * @var string
   */
  public $queueNamePrefix = "";

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'queueNamePrefix',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['queueNamePrefix'])) {
        $this->queueNamePrefix = $vals['queueNamePrefix'];
      }
    }
  }

  public function getName() {
    return 'ListQueueRequest';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->queueNamePrefix);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ListQueueRequest');
    if ($this->queueNamePrefix !== null) {
      $xfer += $output->writeFieldBegin('queueNamePrefix', TType::STRING, 1);
      $xfer += $output->writeString($this->queueNamePrefix);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ListQueueResponse {
  static $_TSPEC;

  /**
   * The queueName list with queueNamePrefix;
   * 
   * 
   * @var string[]
   */
  public $queueName = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'queueName',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['queueName'])) {
        $this->queueName = $vals['queueName'];
      }
    }
  }

  public function getName() {
    return 'ListQueueResponse';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::LST) {
            $this->queueName = array();
            $_size9 = 0;
            $_etype12 = 0;
            $xfer += $input->readListBegin($_etype12, $_size9);
            for ($_i13 = 0; $_i13 < $_size9; ++$_i13)
            {
              $elem14 = null;
              $xfer += $input->readString($elem14);
              $this->queueName []= $elem14;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ListQueueResponse');
    if ($this->queueName !== null) {
      if (!is_array($this->queueName)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('queueName', TType::LST, 1);
      {
        $output->writeListBegin(TType::STRING, count($this->queueName));
        {
          foreach ($this->queueName as $iter15)
          {
            $xfer += $output->writeString($iter15);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class SetPermissionRequest {
  static $_TSPEC;

  /**
   * @var string
   */
  public $queueName = null;
  /**
   * @var string
   */
  public $developerId = null;
  /**
   * @var int
   */
  public $permission = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'queueName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'developerId',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'permission',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['queueName'])) {
        $this->queueName = $vals['queueName'];
      }
      if (isset($vals['developerId'])) {
        $this->developerId = $vals['developerId'];
      }
      if (isset($vals['permission'])) {
        $this->permission = $vals['permission'];
      }
    }
  }

  public function getName() {
    return 'SetPermissionRequest';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->queueName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->developerId);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->permission);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('SetPermissionRequest');
    if ($this->queueName !== null) {
      $xfer += $output->writeFieldBegin('queueName', TType::STRING, 1);
      $xfer += $output->writeString($this->queueName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->developerId !== null) {
      $xfer += $output->writeFieldBegin('developerId', TType::STRING, 2);
      $xfer += $output->writeString($this->developerId);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->permission !== null) {
      $xfer += $output->writeFieldBegin('permission', TType::I32, 3);
      $xfer += $output->writeI32($this->permission);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class RevokePermissionRequest {
  static $_TSPEC;

  /**
   * @var string
   */
  public $queueName = null;
  /**
   * @var string
   */
  public $developerId = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'queueName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'developerId',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['queueName'])) {
        $this->queueName = $vals['queueName'];
      }
      if (isset($vals['developerId'])) {
        $this->developerId = $vals['developerId'];
      }
    }
  }

  public function getName() {
    return 'RevokePermissionRequest';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->queueName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->developerId);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('RevokePermissionRequest');
    if ($this->queueName !== null) {
      $xfer += $output->writeFieldBegin('queueName', TType::STRING, 1);
      $xfer += $output->writeString($this->queueName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->developerId !== null) {
      $xfer += $output->writeFieldBegin('developerId', TType::STRING, 2);
      $xfer += $output->writeString($this->developerId);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class QueryPermissionRequest {
  static $_TSPEC;

  /**
   * @var string
   */
  public $queueName = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'queueName',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['queueName'])) {
        $this->queueName = $vals['queueName'];
      }
    }
  }

  public function getName() {
    return 'QueryPermissionRequest';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->queueName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('QueryPermissionRequest');
    if ($this->queueName !== null) {
      $xfer += $output->writeFieldBegin('queueName', TType::STRING, 1);
      $xfer += $output->writeString($this->queueName);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class QueryPermissionResponse {
  static $_TSPEC;

  /**
   * @var int
   */
  public $permission = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'permission',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['permission'])) {
        $this->permission = $vals['permission'];
      }
    }
  }

  public function getName() {
    return 'QueryPermissionResponse';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->permission);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('QueryPermissionResponse');
    if ($this->permission !== null) {
      $xfer += $output->writeFieldBegin('permission', TType::I32, 1);
      $xfer += $output->writeI32($this->permission);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class QueryPermissionForIdRequest {
  static $_TSPEC;

  /**
   * @var string
   */
  public $queueName = null;
  /**
   * @var string
   */
  public $developerId = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'queueName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'developerId',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['queueName'])) {
        $this->queueName = $vals['queueName'];
      }
      if (isset($vals['developerId'])) {
        $this->developerId = $vals['developerId'];
      }
    }
  }

  public function getName() {
    return 'QueryPermissionForIdRequest';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->queueName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->developerId);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('QueryPermissionForIdRequest');
    if ($this->queueName !== null) {
      $xfer += $output->writeFieldBegin('queueName', TType::STRING, 1);
      $xfer += $output->writeString($this->queueName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->developerId !== null) {
      $xfer += $output->writeFieldBegin('developerId', TType::STRING, 2);
      $xfer += $output->writeString($this->developerId);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class QueryPermissionForIdResponse {
  static $_TSPEC;

  /**
   * @var int
   */
  public $permission = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'permission',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['permission'])) {
        $this->permission = $vals['permission'];
      }
    }
  }

  public function getName() {
    return 'QueryPermissionForIdResponse';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->permission);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('QueryPermissionForIdResponse');
    if ($this->permission !== null) {
      $xfer += $output->writeFieldBegin('permission', TType::I32, 1);
      $xfer += $output->writeI32($this->permission);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ListPermissionsRequest {
  static $_TSPEC;

  /**
   * @var string
   */
  public $queueName = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'queueName',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['queueName'])) {
        $this->queueName = $vals['queueName'];
      }
    }
  }

  public function getName() {
    return 'ListPermissionsRequest';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->queueName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ListPermissionsRequest');
    if ($this->queueName !== null) {
      $xfer += $output->writeFieldBegin('queueName', TType::STRING, 1);
      $xfer += $output->writeString($this->queueName);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ListPermissionsResponse {
  static $_TSPEC;

  /**
   * @var array
   */
  public $permissionList = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'permissionList',
          'type' => TType::MAP,
          'ktype' => TType::STRING,
          'vtype' => TType::I32,
          'key' => array(
            'type' => TType::STRING,
          ),
          'val' => array(
            'type' => TType::I32,
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['permissionList'])) {
        $this->permissionList = $vals['permissionList'];
      }
    }
  }

  public function getName() {
    return 'ListPermissionsResponse';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::MAP) {
            $this->permissionList = array();
            $_size16 = 0;
            $_ktype17 = 0;
            $_vtype18 = 0;
            $xfer += $input->readMapBegin($_ktype17, $_vtype18, $_size16);
            for ($_i20 = 0; $_i20 < $_size16; ++$_i20)
            {
              $key21 = '';
              $val22 = 0;
              $xfer += $input->readString($key21);
              $xfer += $input->readI32($val22);
              $this->permissionList[$key21] = $val22;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ListPermissionsResponse');
    if ($this->permissionList !== null) {
      if (!is_array($this->permissionList)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('permissionList', TType::MAP, 1);
      {
        $output->writeMapBegin(TType::STRING, TType::I32, count($this->permissionList));
        {
          foreach ($this->permissionList as $kiter23 => $viter24)
          {
            $xfer += $output->writeString($kiter23);
            $xfer += $output->writeI32($viter24);
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class CreateTagRequest {
  static $_TSPEC;

  /**
   * @var string
   */
  public $queueName = null;
  /**
   * @var string
   */
  public $tagName = null;
  /**
   * @var int
   */
  public $startTimestamp = null;
  /**
   * @var int
   */
  public $readQPSQuota = null;
  /**
   * @var string
   */
  public $attributeName = null;
  /**
   * @var \EMQ\Message\MessageAttribute
   */
  public $attributeValue = null;
  /**
   * @var array
   */
  public $userAttributes = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'queueName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'tagName',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'startTimestamp',
          'type' => TType::I64,
          ),
        4 => array(
          'var' => 'readQPSQuota',
          'type' => TType::I64,
          ),
        5 => array(
          'var' => 'attributeName',
          'type' => TType::STRING,
          ),
        6 => array(
          'var' => 'attributeValue',
          'type' => TType::STRUCT,
          'class' => '\EMQ\Message\MessageAttribute',
          ),
        7 => array(
          'var' => 'userAttributes',
          'type' => TType::MAP,
          'ktype' => TType::STRING,
          'vtype' => TType::STRING,
          'key' => array(
            'type' => TType::STRING,
          ),
          'val' => array(
            'type' => TType::STRING,
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['queueName'])) {
        $this->queueName = $vals['queueName'];
      }
      if (isset($vals['tagName'])) {
        $this->tagName = $vals['tagName'];
      }
      if (isset($vals['startTimestamp'])) {
        $this->startTimestamp = $vals['startTimestamp'];
      }
      if (isset($vals['readQPSQuota'])) {
        $this->readQPSQuota = $vals['readQPSQuota'];
      }
      if (isset($vals['attributeName'])) {
        $this->attributeName = $vals['attributeName'];
      }
      if (isset($vals['attributeValue'])) {
        $this->attributeValue = $vals['attributeValue'];
      }
      if (isset($vals['userAttributes'])) {
        $this->userAttributes = $vals['userAttributes'];
      }
    }
  }

  public function getName() {
    return 'CreateTagRequest';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->queueName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tagName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->startTimestamp);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->readQPSQuota);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->attributeName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::STRUCT) {
            $this->attributeValue = new \EMQ\Message\MessageAttribute();
            $xfer += $this->attributeValue->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 7:
          if ($ftype == TType::MAP) {
            $this->userAttributes = array();
            $_size25 = 0;
            $_ktype26 = 0;
            $_vtype27 = 0;
            $xfer += $input->readMapBegin($_ktype26, $_vtype27, $_size25);
            for ($_i29 = 0; $_i29 < $_size25; ++$_i29)
            {
              $key30 = '';
              $val31 = '';
              $xfer += $input->readString($key30);
              $xfer += $input->readString($val31);
              $this->userAttributes[$key30] = $val31;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('CreateTagRequest');
    if ($this->queueName !== null) {
      $xfer += $output->writeFieldBegin('queueName', TType::STRING, 1);
      $xfer += $output->writeString($this->queueName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tagName !== null) {
      $xfer += $output->writeFieldBegin('tagName', TType::STRING, 2);
      $xfer += $output->writeString($this->tagName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->startTimestamp !== null) {
      $xfer += $output->writeFieldBegin('startTimestamp', TType::I64, 3);
      $xfer += $output->writeI64($this->startTimestamp);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->readQPSQuota !== null) {
      $xfer += $output->writeFieldBegin('readQPSQuota', TType::I64, 4);
      $xfer += $output->writeI64($this->readQPSQuota);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->attributeName !== null) {
      $xfer += $output->writeFieldBegin('attributeName', TType::STRING, 5);
      $xfer += $output->writeString($this->attributeName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->attributeValue !== null) {
      if (!is_object($this->attributeValue)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('attributeValue', TType::STRUCT, 6);
      $xfer += $this->attributeValue->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->userAttributes !== null) {
      if (!is_array($this->userAttributes)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('userAttributes', TType::MAP, 7);
      {
        $output->writeMapBegin(TType::STRING, TType::STRING, count($this->userAttributes));
        {
          foreach ($this->userAttributes as $kiter32 => $viter33)
          {
            $xfer += $output->writeString($kiter32);
            $xfer += $output->writeString($viter33);
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class CreateTagResponse {
  static $_TSPEC;

  /**
   * @var string
   */
  public $queueName = null;
  /**
   * @var string
   */
  public $tagName = null;
  /**
   * @var int
   */
  public $startTimestamp = null;
  /**
   * @var int
   */
  public $readQPSQuota = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'queueName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'tagName',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'startTimestamp',
          'type' => TType::I64,
          ),
        4 => array(
          'var' => 'readQPSQuota',
          'type' => TType::I64,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['queueName'])) {
        $this->queueName = $vals['queueName'];
      }
      if (isset($vals['tagName'])) {
        $this->tagName = $vals['tagName'];
      }
      if (isset($vals['startTimestamp'])) {
        $this->startTimestamp = $vals['startTimestamp'];
      }
      if (isset($vals['readQPSQuota'])) {
        $this->readQPSQuota = $vals['readQPSQuota'];
      }
    }
  }

  public function getName() {
    return 'CreateTagResponse';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->queueName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tagName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->startTimestamp);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->readQPSQuota);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('CreateTagResponse');
    if ($this->queueName !== null) {
      $xfer += $output->writeFieldBegin('queueName', TType::STRING, 1);
      $xfer += $output->writeString($this->queueName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tagName !== null) {
      $xfer += $output->writeFieldBegin('tagName', TType::STRING, 2);
      $xfer += $output->writeString($this->tagName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->startTimestamp !== null) {
      $xfer += $output->writeFieldBegin('startTimestamp', TType::I64, 3);
      $xfer += $output->writeI64($this->startTimestamp);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->readQPSQuota !== null) {
      $xfer += $output->writeFieldBegin('readQPSQuota', TType::I64, 4);
      $xfer += $output->writeI64($this->readQPSQuota);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class DeleteTagRequest {
  static $_TSPEC;

  /**
   * @var string
   */
  public $queueName = null;
  /**
   * @var string
   */
  public $tagName = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'queueName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'tagName',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['queueName'])) {
        $this->queueName = $vals['queueName'];
      }
      if (isset($vals['tagName'])) {
        $this->tagName = $vals['tagName'];
      }
    }
  }

  public function getName() {
    return 'DeleteTagRequest';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->queueName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tagName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('DeleteTagRequest');
    if ($this->queueName !== null) {
      $xfer += $output->writeFieldBegin('queueName', TType::STRING, 1);
      $xfer += $output->writeString($this->queueName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tagName !== null) {
      $xfer += $output->writeFieldBegin('tagName', TType::STRING, 2);
      $xfer += $output->writeString($this->tagName);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class GetTagInfoRequest {
  static $_TSPEC;

  /**
   * @var string
   */
  public $queueName = null;
  /**
   * @var string
   */
  public $tagName = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'queueName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'tagName',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['queueName'])) {
        $this->queueName = $vals['queueName'];
      }
      if (isset($vals['tagName'])) {
        $this->tagName = $vals['tagName'];
      }
    }
  }

  public function getName() {
    return 'GetTagInfoRequest';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->queueName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tagName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('GetTagInfoRequest');
    if ($this->queueName !== null) {
      $xfer += $output->writeFieldBegin('queueName', TType::STRING, 1);
      $xfer += $output->writeString($this->queueName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tagName !== null) {
      $xfer += $output->writeFieldBegin('tagName', TType::STRING, 2);
      $xfer += $output->writeString($this->tagName);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class GetTagInfoResponse {
  static $_TSPEC;

  /**
   * @var string
   */
  public $queueName = null;
  /**
   * @var string
   */
  public $tagName = null;
  /**
   * @var \EMQ\Queue\QueueState
   */
  public $tagState = null;
  /**
   * @var int
   */
  public $startTimestamp = null;
  /**
   * @var int
   */
  public $readQPSQuota = null;
  /**
   * @var string
   */
  public $attributeName = null;
  /**
   * @var \EMQ\Message\MessageAttribute
   */
  public $attributeValue = null;
  /**
   * @var array
   */
  public $userAttributes = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'queueName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'tagName',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'tagState',
          'type' => TType::STRUCT,
          'class' => '\EMQ\Queue\QueueState',
          ),
        4 => array(
          'var' => 'startTimestamp',
          'type' => TType::I64,
          ),
        5 => array(
          'var' => 'readQPSQuota',
          'type' => TType::I64,
          ),
        6 => array(
          'var' => 'attributeName',
          'type' => TType::STRING,
          ),
        7 => array(
          'var' => 'attributeValue',
          'type' => TType::STRUCT,
          'class' => '\EMQ\Message\MessageAttribute',
          ),
        8 => array(
          'var' => 'userAttributes',
          'type' => TType::MAP,
          'ktype' => TType::STRING,
          'vtype' => TType::STRING,
          'key' => array(
            'type' => TType::STRING,
          ),
          'val' => array(
            'type' => TType::STRING,
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['queueName'])) {
        $this->queueName = $vals['queueName'];
      }
      if (isset($vals['tagName'])) {
        $this->tagName = $vals['tagName'];
      }
      if (isset($vals['tagState'])) {
        $this->tagState = $vals['tagState'];
      }
      if (isset($vals['startTimestamp'])) {
        $this->startTimestamp = $vals['startTimestamp'];
      }
      if (isset($vals['readQPSQuota'])) {
        $this->readQPSQuota = $vals['readQPSQuota'];
      }
      if (isset($vals['attributeName'])) {
        $this->attributeName = $vals['attributeName'];
      }
      if (isset($vals['attributeValue'])) {
        $this->attributeValue = $vals['attributeValue'];
      }
      if (isset($vals['userAttributes'])) {
        $this->userAttributes = $vals['userAttributes'];
      }
    }
  }

  public function getName() {
    return 'GetTagInfoResponse';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->queueName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tagName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->tagState = new \EMQ\Queue\QueueState();
            $xfer += $this->tagState->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->startTimestamp);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->readQPSQuota);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->attributeName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 7:
          if ($ftype == TType::STRUCT) {
            $this->attributeValue = new \EMQ\Message\MessageAttribute();
            $xfer += $this->attributeValue->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 8:
          if ($ftype == TType::MAP) {
            $this->userAttributes = array();
            $_size34 = 0;
            $_ktype35 = 0;
            $_vtype36 = 0;
            $xfer += $input->readMapBegin($_ktype35, $_vtype36, $_size34);
            for ($_i38 = 0; $_i38 < $_size34; ++$_i38)
            {
              $key39 = '';
              $val40 = '';
              $xfer += $input->readString($key39);
              $xfer += $input->readString($val40);
              $this->userAttributes[$key39] = $val40;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('GetTagInfoResponse');
    if ($this->queueName !== null) {
      $xfer += $output->writeFieldBegin('queueName', TType::STRING, 1);
      $xfer += $output->writeString($this->queueName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tagName !== null) {
      $xfer += $output->writeFieldBegin('tagName', TType::STRING, 2);
      $xfer += $output->writeString($this->tagName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tagState !== null) {
      if (!is_object($this->tagState)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('tagState', TType::STRUCT, 3);
      $xfer += $this->tagState->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->startTimestamp !== null) {
      $xfer += $output->writeFieldBegin('startTimestamp', TType::I64, 4);
      $xfer += $output->writeI64($this->startTimestamp);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->readQPSQuota !== null) {
      $xfer += $output->writeFieldBegin('readQPSQuota', TType::I64, 5);
      $xfer += $output->writeI64($this->readQPSQuota);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->attributeName !== null) {
      $xfer += $output->writeFieldBegin('attributeName', TType::STRING, 6);
      $xfer += $output->writeString($this->attributeName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->attributeValue !== null) {
      if (!is_object($this->attributeValue)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('attributeValue', TType::STRUCT, 7);
      $xfer += $this->attributeValue->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->userAttributes !== null) {
      if (!is_array($this->userAttributes)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('userAttributes', TType::MAP, 8);
      {
        $output->writeMapBegin(TType::STRING, TType::STRING, count($this->userAttributes));
        {
          foreach ($this->userAttributes as $kiter41 => $viter42)
          {
            $xfer += $output->writeString($kiter41);
            $xfer += $output->writeString($viter42);
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ListTagRequest {
  static $_TSPEC;

  /**
   * @var string
   */
  public $queueName = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'queueName',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['queueName'])) {
        $this->queueName = $vals['queueName'];
      }
    }
  }

  public function getName() {
    return 'ListTagRequest';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->queueName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ListTagRequest');
    if ($this->queueName !== null) {
      $xfer += $output->writeFieldBegin('queueName', TType::STRING, 1);
      $xfer += $output->writeString($this->queueName);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ListTagResponse {
  static $_TSPEC;

  /**
   * @var string
   */
  public $queueName = null;
  /**
   * @var string[]
   */
  public $tagName = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'queueName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'tagName',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['queueName'])) {
        $this->queueName = $vals['queueName'];
      }
      if (isset($vals['tagName'])) {
        $this->tagName = $vals['tagName'];
      }
    }
  }

  public function getName() {
    return 'ListTagResponse';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->queueName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::LST) {
            $this->tagName = array();
            $_size43 = 0;
            $_etype46 = 0;
            $xfer += $input->readListBegin($_etype46, $_size43);
            for ($_i47 = 0; $_i47 < $_size43; ++$_i47)
            {
              $elem48 = null;
              $xfer += $input->readString($elem48);
              $this->tagName []= $elem48;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ListTagResponse');
    if ($this->queueName !== null) {
      $xfer += $output->writeFieldBegin('queueName', TType::STRING, 1);
      $xfer += $output->writeString($this->queueName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tagName !== null) {
      if (!is_array($this->tagName)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('tagName', TType::LST, 2);
      {
        $output->writeListBegin(TType::STRING, count($this->tagName));
        {
          foreach ($this->tagName as $iter49)
          {
            $xfer += $output->writeString($iter49);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class QueryMetricRequest {
  static $_TSPEC;

  /**
   * @var string
   */
  public $queueName = null;
  /**
   * @var int
   */
  public $startTime = null;
  /**
   * @var int
   */
  public $endTime = null;
  /**
   * metric name
   * 
   * 
   * @var string
   */
  public $metrics = null;
  /**
   * tags, reference to opentsdb,
   * e.g. <"type", "">
   * 
   * 
   * @var array
   */
  public $tags = null;
  /**
   * data aggregator, reference to opentsdb,
   * e.g. max, avg, min
   * 
   * 
   * @var string
   */
  public $aggregator = null;
  /**
   * similar to aggregator above
   * 
   * 
   * @var string
   */
  public $downsampleAggregator = null;
  /**
   * @var int
   */
  public $downsampleInterval = null;
  /**
   * downsample interval unit, reference to opentsdb,
   * e.g. ms(milliseconds), s(seconds), d(day)
   * 
   * 
   * @var string
   */
  public $downsampleTimeUnit = null;
  /**
   * @var bool
   */
  public $calRate = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'queueName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'startTime',
          'type' => TType::I64,
          ),
        3 => array(
          'var' => 'endTime',
          'type' => TType::I64,
          ),
        4 => array(
          'var' => 'metrics',
          'type' => TType::STRING,
          ),
        5 => array(
          'var' => 'tags',
          'type' => TType::MAP,
          'ktype' => TType::STRING,
          'vtype' => TType::STRING,
          'key' => array(
            'type' => TType::STRING,
          ),
          'val' => array(
            'type' => TType::STRING,
            ),
          ),
        6 => array(
          'var' => 'aggregator',
          'type' => TType::STRING,
          ),
        7 => array(
          'var' => 'downsampleAggregator',
          'type' => TType::STRING,
          ),
        8 => array(
          'var' => 'downsampleInterval',
          'type' => TType::I32,
          ),
        9 => array(
          'var' => 'downsampleTimeUnit',
          'type' => TType::STRING,
          ),
        10 => array(
          'var' => 'calRate',
          'type' => TType::BOOL,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['queueName'])) {
        $this->queueName = $vals['queueName'];
      }
      if (isset($vals['startTime'])) {
        $this->startTime = $vals['startTime'];
      }
      if (isset($vals['endTime'])) {
        $this->endTime = $vals['endTime'];
      }
      if (isset($vals['metrics'])) {
        $this->metrics = $vals['metrics'];
      }
      if (isset($vals['tags'])) {
        $this->tags = $vals['tags'];
      }
      if (isset($vals['aggregator'])) {
        $this->aggregator = $vals['aggregator'];
      }
      if (isset($vals['downsampleAggregator'])) {
        $this->downsampleAggregator = $vals['downsampleAggregator'];
      }
      if (isset($vals['downsampleInterval'])) {
        $this->downsampleInterval = $vals['downsampleInterval'];
      }
      if (isset($vals['downsampleTimeUnit'])) {
        $this->downsampleTimeUnit = $vals['downsampleTimeUnit'];
      }
      if (isset($vals['calRate'])) {
        $this->calRate = $vals['calRate'];
      }
    }
  }

  public function getName() {
    return 'QueryMetricRequest';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->queueName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->startTime);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->endTime);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->metrics);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::MAP) {
            $this->tags = array();
            $_size50 = 0;
            $_ktype51 = 0;
            $_vtype52 = 0;
            $xfer += $input->readMapBegin($_ktype51, $_vtype52, $_size50);
            for ($_i54 = 0; $_i54 < $_size50; ++$_i54)
            {
              $key55 = '';
              $val56 = '';
              $xfer += $input->readString($key55);
              $xfer += $input->readString($val56);
              $this->tags[$key55] = $val56;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->aggregator);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 7:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->downsampleAggregator);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 8:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->downsampleInterval);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 9:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->downsampleTimeUnit);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 10:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->calRate);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('QueryMetricRequest');
    if ($this->queueName !== null) {
      $xfer += $output->writeFieldBegin('queueName', TType::STRING, 1);
      $xfer += $output->writeString($this->queueName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->startTime !== null) {
      $xfer += $output->writeFieldBegin('startTime', TType::I64, 2);
      $xfer += $output->writeI64($this->startTime);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->endTime !== null) {
      $xfer += $output->writeFieldBegin('endTime', TType::I64, 3);
      $xfer += $output->writeI64($this->endTime);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->metrics !== null) {
      $xfer += $output->writeFieldBegin('metrics', TType::STRING, 4);
      $xfer += $output->writeString($this->metrics);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tags !== null) {
      if (!is_array($this->tags)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('tags', TType::MAP, 5);
      {
        $output->writeMapBegin(TType::STRING, TType::STRING, count($this->tags));
        {
          foreach ($this->tags as $kiter57 => $viter58)
          {
            $xfer += $output->writeString($kiter57);
            $xfer += $output->writeString($viter58);
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->aggregator !== null) {
      $xfer += $output->writeFieldBegin('aggregator', TType::STRING, 6);
      $xfer += $output->writeString($this->aggregator);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->downsampleAggregator !== null) {
      $xfer += $output->writeFieldBegin('downsampleAggregator', TType::STRING, 7);
      $xfer += $output->writeString($this->downsampleAggregator);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->downsampleInterval !== null) {
      $xfer += $output->writeFieldBegin('downsampleInterval', TType::I32, 8);
      $xfer += $output->writeI32($this->downsampleInterval);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->downsampleTimeUnit !== null) {
      $xfer += $output->writeFieldBegin('downsampleTimeUnit', TType::STRING, 9);
      $xfer += $output->writeString($this->downsampleTimeUnit);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->calRate !== null) {
      $xfer += $output->writeFieldBegin('calRate', TType::BOOL, 10);
      $xfer += $output->writeBool($this->calRate);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * metrics time series data
 */
class TimeSeriesData {
  static $_TSPEC;

  /**
   * metric name
   * 
   * @var string
   */
  public $metric = null;
  /**
   * tags
   * 
   * @var array
   */
  public $tags = null;
  /**
   * data, {timestamp => value}
   * 
   * @var array
   */
  public $data = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'metric',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'tags',
          'type' => TType::MAP,
          'ktype' => TType::STRING,
          'vtype' => TType::STRING,
          'key' => array(
            'type' => TType::STRING,
          ),
          'val' => array(
            'type' => TType::STRING,
            ),
          ),
        3 => array(
          'var' => 'data',
          'type' => TType::MAP,
          'ktype' => TType::I64,
          'vtype' => TType::DOUBLE,
          'key' => array(
            'type' => TType::I64,
          ),
          'val' => array(
            'type' => TType::DOUBLE,
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['metric'])) {
        $this->metric = $vals['metric'];
      }
      if (isset($vals['tags'])) {
        $this->tags = $vals['tags'];
      }
      if (isset($vals['data'])) {
        $this->data = $vals['data'];
      }
    }
  }

  public function getName() {
    return 'TimeSeriesData';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->metric);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::MAP) {
            $this->tags = array();
            $_size59 = 0;
            $_ktype60 = 0;
            $_vtype61 = 0;
            $xfer += $input->readMapBegin($_ktype60, $_vtype61, $_size59);
            for ($_i63 = 0; $_i63 < $_size59; ++$_i63)
            {
              $key64 = '';
              $val65 = '';
              $xfer += $input->readString($key64);
              $xfer += $input->readString($val65);
              $this->tags[$key64] = $val65;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::MAP) {
            $this->data = array();
            $_size66 = 0;
            $_ktype67 = 0;
            $_vtype68 = 0;
            $xfer += $input->readMapBegin($_ktype67, $_vtype68, $_size66);
            for ($_i70 = 0; $_i70 < $_size66; ++$_i70)
            {
              $key71 = 0;
              $val72 = 0.0;
              $xfer += $input->readI64($key71);
              $xfer += $input->readDouble($val72);
              $this->data[$key71] = $val72;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TimeSeriesData');
    if ($this->metric !== null) {
      $xfer += $output->writeFieldBegin('metric', TType::STRING, 1);
      $xfer += $output->writeString($this->metric);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tags !== null) {
      if (!is_array($this->tags)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('tags', TType::MAP, 2);
      {
        $output->writeMapBegin(TType::STRING, TType::STRING, count($this->tags));
        {
          foreach ($this->tags as $kiter73 => $viter74)
          {
            $xfer += $output->writeString($kiter73);
            $xfer += $output->writeString($viter74);
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->data !== null) {
      if (!is_array($this->data)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('data', TType::MAP, 3);
      {
        $output->writeMapBegin(TType::I64, TType::DOUBLE, count($this->data));
        {
          foreach ($this->data as $kiter75 => $viter76)
          {
            $xfer += $output->writeI64($kiter75);
            $xfer += $output->writeDouble($viter76);
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}


