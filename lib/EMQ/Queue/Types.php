<?php
namespace EMQ\Queue;

/**
 * Autogenerated by Thrift Compiler (0.9.2)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
use Thrift\Base\TBase;
use Thrift\Type\TType;
use Thrift\Type\TMessageType;
use Thrift\Exception\TException;
use Thrift\Exception\TProtocolException;
use Thrift\Protocol\TProtocol;
use Thrift\Protocol\TBinaryProtocolAccelerated;
use Thrift\Exception\TApplicationException;


final class Permission {
  const NONE = 0;
  const SEND_MESSAGE = 1;
  const RECEIVE_MESSAGE = 2;
  const SEND_RECEIVE_MESSAGE = 3;
  const HANDLE_MESSAGE = 4;
  const SEND_HANDLE_MESSAGE = 5;
  const GET_QUEUE_INFO = 6;
  const USE_QUEUE = 7;
  const ADMIN_QUEUE = 8;
  const FULL_CONTROL = 9;
  static public $__names = array(
    0 => 'NONE',
    1 => 'SEND_MESSAGE',
    2 => 'RECEIVE_MESSAGE',
    3 => 'SEND_RECEIVE_MESSAGE',
    4 => 'HANDLE_MESSAGE',
    5 => 'SEND_HANDLE_MESSAGE',
    6 => 'GET_QUEUE_INFO',
    7 => 'USE_QUEUE',
    8 => 'ADMIN_QUEUE',
    9 => 'FULL_CONTROL',
  );
}

/**
 * Copyright 2015, Xiaomi.
 * All rights reserved.
 * Author: shenyuannan@xiaomi.com
 */
class QueueAttribute {
  static $_TSPEC;

  /**
   * Queue delay seconds, message send to this queue will invisible until after
   * delaySeconds, default 0s (0s ~ 15min)
   * 
   * 
   * @var int
   */
  public $delaySeconds = null;
  /**
   * Queue invisibility seconds, after message received form this queue, in
   * invisibilitySeconds this will not received through receiveMessage. When
   * after invisibilitySeconds if no deleteMessage called for this message, this
   * message will receive again, default 30s (2s ~ 12hour)
   * 
   * 
   * @var int
   */
  public $invisibilitySeconds = null;
  /**
   * The seconds wait when receiveMessage called, default 0s (0s ~ 20s)
   * 
   * 
   * @var int
   */
  public $receiveMessageWaitSeconds = null;
  /**
   * Maximum receive message number in this queue, default 100(1 ~ 100)
   * 
   * 
   * @var int
   */
  public $receiveMessageMaximumNumber = null;
  /**
   * message retention seconds in this queue, default 4days (60s ~ 14days)
   * 
   * 
   * @var int
   */
  public $messageRetentionSeconds = null;
  /**
   * Max message size in this queue, default 256K (1K ~ 256K)
   * 
   * 
   * @var int
   */
  public $messageMaximumBytes = null;
  /**
   * Partition number for this queue default 4 (1 ~ 255)
   * 
   * 
   * @var int
   */
  public $partitionNumber = null;
  /**
   * User-defined attributes;
   * 
   * 
   * @var array
   */
  public $userAttributes = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'delaySeconds',
          'type' => TType::I32,
          ),
        2 => array(
          'var' => 'invisibilitySeconds',
          'type' => TType::I32,
          ),
        3 => array(
          'var' => 'receiveMessageWaitSeconds',
          'type' => TType::I32,
          ),
        4 => array(
          'var' => 'receiveMessageMaximumNumber',
          'type' => TType::I32,
          ),
        5 => array(
          'var' => 'messageRetentionSeconds',
          'type' => TType::I32,
          ),
        6 => array(
          'var' => 'messageMaximumBytes',
          'type' => TType::I32,
          ),
        7 => array(
          'var' => 'partitionNumber',
          'type' => TType::I32,
          ),
        8 => array(
          'var' => 'userAttributes',
          'type' => TType::MAP,
          'ktype' => TType::STRING,
          'vtype' => TType::STRING,
          'key' => array(
            'type' => TType::STRING,
          ),
          'val' => array(
            'type' => TType::STRING,
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['delaySeconds'])) {
        $this->delaySeconds = $vals['delaySeconds'];
      }
      if (isset($vals['invisibilitySeconds'])) {
        $this->invisibilitySeconds = $vals['invisibilitySeconds'];
      }
      if (isset($vals['receiveMessageWaitSeconds'])) {
        $this->receiveMessageWaitSeconds = $vals['receiveMessageWaitSeconds'];
      }
      if (isset($vals['receiveMessageMaximumNumber'])) {
        $this->receiveMessageMaximumNumber = $vals['receiveMessageMaximumNumber'];
      }
      if (isset($vals['messageRetentionSeconds'])) {
        $this->messageRetentionSeconds = $vals['messageRetentionSeconds'];
      }
      if (isset($vals['messageMaximumBytes'])) {
        $this->messageMaximumBytes = $vals['messageMaximumBytes'];
      }
      if (isset($vals['partitionNumber'])) {
        $this->partitionNumber = $vals['partitionNumber'];
      }
      if (isset($vals['userAttributes'])) {
        $this->userAttributes = $vals['userAttributes'];
      }
    }
  }

  public function getName() {
    return 'QueueAttribute';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->delaySeconds);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->invisibilitySeconds);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->receiveMessageWaitSeconds);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->receiveMessageMaximumNumber);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->messageRetentionSeconds);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->messageMaximumBytes);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 7:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->partitionNumber);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 8:
          if ($ftype == TType::MAP) {
            $this->userAttributes = array();
            $_size0 = 0;
            $_ktype1 = 0;
            $_vtype2 = 0;
            $xfer += $input->readMapBegin($_ktype1, $_vtype2, $_size0);
            for ($_i4 = 0; $_i4 < $_size0; ++$_i4)
            {
              $key5 = '';
              $val6 = '';
              $xfer += $input->readString($key5);
              $xfer += $input->readString($val6);
              $this->userAttributes[$key5] = $val6;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('QueueAttribute');
    if ($this->delaySeconds !== null) {
      $xfer += $output->writeFieldBegin('delaySeconds', TType::I32, 1);
      $xfer += $output->writeI32($this->delaySeconds);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->invisibilitySeconds !== null) {
      $xfer += $output->writeFieldBegin('invisibilitySeconds', TType::I32, 2);
      $xfer += $output->writeI32($this->invisibilitySeconds);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->receiveMessageWaitSeconds !== null) {
      $xfer += $output->writeFieldBegin('receiveMessageWaitSeconds', TType::I32, 3);
      $xfer += $output->writeI32($this->receiveMessageWaitSeconds);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->receiveMessageMaximumNumber !== null) {
      $xfer += $output->writeFieldBegin('receiveMessageMaximumNumber', TType::I32, 4);
      $xfer += $output->writeI32($this->receiveMessageMaximumNumber);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->messageRetentionSeconds !== null) {
      $xfer += $output->writeFieldBegin('messageRetentionSeconds', TType::I32, 5);
      $xfer += $output->writeI32($this->messageRetentionSeconds);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->messageMaximumBytes !== null) {
      $xfer += $output->writeFieldBegin('messageMaximumBytes', TType::I32, 6);
      $xfer += $output->writeI32($this->messageMaximumBytes);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->partitionNumber !== null) {
      $xfer += $output->writeFieldBegin('partitionNumber', TType::I32, 7);
      $xfer += $output->writeI32($this->partitionNumber);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->userAttributes !== null) {
      if (!is_array($this->userAttributes)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('userAttributes', TType::MAP, 8);
      {
        $output->writeMapBegin(TType::STRING, TType::STRING, count($this->userAttributes));
        {
          foreach ($this->userAttributes as $kiter7 => $viter8)
          {
            $xfer += $output->writeString($kiter7);
            $xfer += $output->writeString($viter8);
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class QueueState {
  static $_TSPEC;

  /**
   * Queue create timestamp;
   * 
   * 
   * @var int
   */
  public $createTimestamp = null;
  /**
   * Queue last modified timestamp;
   * 
   * 
   * @var int
   */
  public $lastModifiedTimestamp = null;
  /**
   * The approximate message number in this queue;
   * 
   * 
   * @var int
   */
  public $approximateMessageNumber = null;
  /**
   * The available message number in this queue, this is for message that could
   * be get using receivedMessage
   * 
   * 
   * @var int
   */
  public $approximateAvailableMessageNumber = null;
  /**
   * The invisibility message number in this queue, this is for received message
   * that in invisibilitySeconds and not deleted;
   * 
   * 
   * @var int
   */
  public $approximateInvisibilityMessageNumber = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'createTimestamp',
          'type' => TType::I64,
          ),
        2 => array(
          'var' => 'lastModifiedTimestamp',
          'type' => TType::I64,
          ),
        3 => array(
          'var' => 'approximateMessageNumber',
          'type' => TType::I64,
          ),
        4 => array(
          'var' => 'approximateAvailableMessageNumber',
          'type' => TType::I64,
          ),
        5 => array(
          'var' => 'approximateInvisibilityMessageNumber',
          'type' => TType::I64,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['createTimestamp'])) {
        $this->createTimestamp = $vals['createTimestamp'];
      }
      if (isset($vals['lastModifiedTimestamp'])) {
        $this->lastModifiedTimestamp = $vals['lastModifiedTimestamp'];
      }
      if (isset($vals['approximateMessageNumber'])) {
        $this->approximateMessageNumber = $vals['approximateMessageNumber'];
      }
      if (isset($vals['approximateAvailableMessageNumber'])) {
        $this->approximateAvailableMessageNumber = $vals['approximateAvailableMessageNumber'];
      }
      if (isset($vals['approximateInvisibilityMessageNumber'])) {
        $this->approximateInvisibilityMessageNumber = $vals['approximateInvisibilityMessageNumber'];
      }
    }
  }

  public function getName() {
    return 'QueueState';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->createTimestamp);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->lastModifiedTimestamp);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->approximateMessageNumber);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->approximateAvailableMessageNumber);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->approximateInvisibilityMessageNumber);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('QueueState');
    if ($this->createTimestamp !== null) {
      $xfer += $output->writeFieldBegin('createTimestamp', TType::I64, 1);
      $xfer += $output->writeI64($this->createTimestamp);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->lastModifiedTimestamp !== null) {
      $xfer += $output->writeFieldBegin('lastModifiedTimestamp', TType::I64, 2);
      $xfer += $output->writeI64($this->lastModifiedTimestamp);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->approximateMessageNumber !== null) {
      $xfer += $output->writeFieldBegin('approximateMessageNumber', TType::I64, 3);
      $xfer += $output->writeI64($this->approximateMessageNumber);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->approximateAvailableMessageNumber !== null) {
      $xfer += $output->writeFieldBegin('approximateAvailableMessageNumber', TType::I64, 4);
      $xfer += $output->writeI64($this->approximateAvailableMessageNumber);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->approximateInvisibilityMessageNumber !== null) {
      $xfer += $output->writeFieldBegin('approximateInvisibilityMessageNumber', TType::I64, 5);
      $xfer += $output->writeI64($this->approximateInvisibilityMessageNumber);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Throughput {
  static $_TSPEC;

  /**
   * Queue read qps;
   * 
   * 
   * @var int
   */
  public $readQps = null;
  /**
   * Queue write qps;
   * 
   * 
   * @var int
   */
  public $writeQps = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'readQps',
          'type' => TType::I64,
          ),
        2 => array(
          'var' => 'writeQps',
          'type' => TType::I64,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['readQps'])) {
        $this->readQps = $vals['readQps'];
      }
      if (isset($vals['writeQps'])) {
        $this->writeQps = $vals['writeQps'];
      }
    }
  }

  public function getName() {
    return 'Throughput';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->readQps);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->writeQps);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Throughput');
    if ($this->readQps !== null) {
      $xfer += $output->writeFieldBegin('readQps', TType::I64, 1);
      $xfer += $output->writeI64($this->readQps);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->writeQps !== null) {
      $xfer += $output->writeFieldBegin('writeQps', TType::I64, 2);
      $xfer += $output->writeI64($this->writeQps);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class SpaceQuota {
  static $_TSPEC;

  /**
   * Queue read qps;
   * 
   * 
   * @var int
   */
  public $size = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'size',
          'type' => TType::I64,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['size'])) {
        $this->size = $vals['size'];
      }
    }
  }

  public function getName() {
    return 'SpaceQuota';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->size);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('SpaceQuota');
    if ($this->size !== null) {
      $xfer += $output->writeFieldBegin('size', TType::I64, 1);
      $xfer += $output->writeI64($this->size);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class QueueQuota {
  static $_TSPEC;

  /**
   * Queue space quota;
   * 
   * 
   * @var \EMQ\Queue\SpaceQuota
   */
  public $spaceQuota = null;
  /**
   * Queue read and qps;
   * 
   * 
   * @var \EMQ\Queue\Throughput
   */
  public $throughput = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'spaceQuota',
          'type' => TType::STRUCT,
          'class' => '\EMQ\Queue\SpaceQuota',
          ),
        2 => array(
          'var' => 'throughput',
          'type' => TType::STRUCT,
          'class' => '\EMQ\Queue\Throughput',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['spaceQuota'])) {
        $this->spaceQuota = $vals['spaceQuota'];
      }
      if (isset($vals['throughput'])) {
        $this->throughput = $vals['throughput'];
      }
    }
  }

  public function getName() {
    return 'QueueQuota';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->spaceQuota = new \EMQ\Queue\SpaceQuota();
            $xfer += $this->spaceQuota->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->throughput = new \EMQ\Queue\Throughput();
            $xfer += $this->throughput->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('QueueQuota');
    if ($this->spaceQuota !== null) {
      if (!is_object($this->spaceQuota)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('spaceQuota', TType::STRUCT, 1);
      $xfer += $this->spaceQuota->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->throughput !== null) {
      if (!is_object($this->throughput)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('throughput', TType::STRUCT, 2);
      $xfer += $this->throughput->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class CreateQueueRequest {
  static $_TSPEC;

  /**
   * The queue name;
   * 
   * 
   * @var string
   */
  public $queueName = null;
  /**
   * The queue attribute;
   * 
   * 
   * @var \EMQ\Queue\QueueAttribute
   */
  public $queueAttribute = null;
  /**
   * The queue quota, including space quota, read qps, and write qps;
   * 
   * 
   * @var \EMQ\Queue\QueueQuota
   */
  public $queueQuota = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'queueName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'queueAttribute',
          'type' => TType::STRUCT,
          'class' => '\EMQ\Queue\QueueAttribute',
          ),
        3 => array(
          'var' => 'queueQuota',
          'type' => TType::STRUCT,
          'class' => '\EMQ\Queue\QueueQuota',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['queueName'])) {
        $this->queueName = $vals['queueName'];
      }
      if (isset($vals['queueAttribute'])) {
        $this->queueAttribute = $vals['queueAttribute'];
      }
      if (isset($vals['queueQuota'])) {
        $this->queueQuota = $vals['queueQuota'];
      }
    }
  }

  public function getName() {
    return 'CreateQueueRequest';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->queueName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->queueAttribute = new \EMQ\Queue\QueueAttribute();
            $xfer += $this->queueAttribute->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->queueQuota = new \EMQ\Queue\QueueQuota();
            $xfer += $this->queueQuota->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('CreateQueueRequest');
    if ($this->queueName !== null) {
      $xfer += $output->writeFieldBegin('queueName', TType::STRING, 1);
      $xfer += $output->writeString($this->queueName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->queueAttribute !== null) {
      if (!is_object($this->queueAttribute)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('queueAttribute', TType::STRUCT, 2);
      $xfer += $this->queueAttribute->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->queueQuota !== null) {
      if (!is_object($this->queueQuota)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('queueQuota', TType::STRUCT, 3);
      $xfer += $this->queueQuota->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class CreateQueueResponse {
  static $_TSPEC;

  /**
   * The queue name;
   * The name returned here may be a little different from user set in request (with developerId as prefix).
   * So the user should use the name returned by this response for those following operations
   * 
   * 
   * @var string
   */
  public $queueName = null;
  /**
   * The queue attribute;
   * 
   * 
   * @var \EMQ\Queue\QueueAttribute
   */
  public $queueAttribute = null;
  /**
   * The queue quota;
   * 
   * 
   * @var \EMQ\Queue\QueueQuota
   */
  public $queueQuota = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'queueName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'queueAttribute',
          'type' => TType::STRUCT,
          'class' => '\EMQ\Queue\QueueAttribute',
          ),
        3 => array(
          'var' => 'queueQuota',
          'type' => TType::STRUCT,
          'class' => '\EMQ\Queue\QueueQuota',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['queueName'])) {
        $this->queueName = $vals['queueName'];
      }
      if (isset($vals['queueAttribute'])) {
        $this->queueAttribute = $vals['queueAttribute'];
      }
      if (isset($vals['queueQuota'])) {
        $this->queueQuota = $vals['queueQuota'];
      }
    }
  }

  public function getName() {
    return 'CreateQueueResponse';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->queueName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->queueAttribute = new \EMQ\Queue\QueueAttribute();
            $xfer += $this->queueAttribute->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->queueQuota = new \EMQ\Queue\QueueQuota();
            $xfer += $this->queueQuota->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('CreateQueueResponse');
    if ($this->queueName !== null) {
      $xfer += $output->writeFieldBegin('queueName', TType::STRING, 1);
      $xfer += $output->writeString($this->queueName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->queueAttribute !== null) {
      if (!is_object($this->queueAttribute)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('queueAttribute', TType::STRUCT, 2);
      $xfer += $this->queueAttribute->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->queueQuota !== null) {
      if (!is_object($this->queueQuota)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('queueQuota', TType::STRUCT, 3);
      $xfer += $this->queueQuota->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class DeleteQueueRequest {
  static $_TSPEC;

  /**
   * The queue name;
   * 
   * 
   * @var string
   */
  public $queueName = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'queueName',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['queueName'])) {
        $this->queueName = $vals['queueName'];
      }
    }
  }

  public function getName() {
    return 'DeleteQueueRequest';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->queueName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('DeleteQueueRequest');
    if ($this->queueName !== null) {
      $xfer += $output->writeFieldBegin('queueName', TType::STRING, 1);
      $xfer += $output->writeString($this->queueName);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class PurgeQueueRequest {
  static $_TSPEC;

  /**
   * The queue name;
   * 
   * 
   * @var string
   */
  public $queueName = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'queueName',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['queueName'])) {
        $this->queueName = $vals['queueName'];
      }
    }
  }

  public function getName() {
    return 'PurgeQueueRequest';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->queueName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('PurgeQueueRequest');
    if ($this->queueName !== null) {
      $xfer += $output->writeFieldBegin('queueName', TType::STRING, 1);
      $xfer += $output->writeString($this->queueName);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class SetQueueAttributesRequest {
  static $_TSPEC;

  /**
   * The queue name;
   * 
   * 
   * @var string
   */
  public $queueName = null;
  /**
   * The queue attribute;
   * 
   * 
   * @var \EMQ\Queue\QueueAttribute
   */
  public $queueAttribute = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'queueName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'queueAttribute',
          'type' => TType::STRUCT,
          'class' => '\EMQ\Queue\QueueAttribute',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['queueName'])) {
        $this->queueName = $vals['queueName'];
      }
      if (isset($vals['queueAttribute'])) {
        $this->queueAttribute = $vals['queueAttribute'];
      }
    }
  }

  public function getName() {
    return 'SetQueueAttributesRequest';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->queueName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->queueAttribute = new \EMQ\Queue\QueueAttribute();
            $xfer += $this->queueAttribute->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('SetQueueAttributesRequest');
    if ($this->queueName !== null) {
      $xfer += $output->writeFieldBegin('queueName', TType::STRING, 1);
      $xfer += $output->writeString($this->queueName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->queueAttribute !== null) {
      if (!is_object($this->queueAttribute)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('queueAttribute', TType::STRUCT, 2);
      $xfer += $this->queueAttribute->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class SetQueueAttributesResponse {
  static $_TSPEC;

  /**
   * The queue name;
   * 
   * 
   * @var string
   */
  public $queueName = null;
  /**
   * The queue attribute;
   * 
   * 
   * @var \EMQ\Queue\QueueAttribute
   */
  public $queueAttribute = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'queueName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'queueAttribute',
          'type' => TType::STRUCT,
          'class' => '\EMQ\Queue\QueueAttribute',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['queueName'])) {
        $this->queueName = $vals['queueName'];
      }
      if (isset($vals['queueAttribute'])) {
        $this->queueAttribute = $vals['queueAttribute'];
      }
    }
  }

  public function getName() {
    return 'SetQueueAttributesResponse';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->queueName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->queueAttribute = new \EMQ\Queue\QueueAttribute();
            $xfer += $this->queueAttribute->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('SetQueueAttributesResponse');
    if ($this->queueName !== null) {
      $xfer += $output->writeFieldBegin('queueName', TType::STRING, 1);
      $xfer += $output->writeString($this->queueName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->queueAttribute !== null) {
      if (!is_object($this->queueAttribute)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('queueAttribute', TType::STRUCT, 2);
      $xfer += $this->queueAttribute->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class SetQueueQuotaRequest {
  static $_TSPEC;

  /**
   * The queue name;
   * 
   * 
   * @var string
   */
  public $queueName = null;
  /**
   * The queue quota;
   * 
   * 
   * @var \EMQ\Queue\QueueQuota
   */
  public $queueQuota = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'queueName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'queueQuota',
          'type' => TType::STRUCT,
          'class' => '\EMQ\Queue\QueueQuota',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['queueName'])) {
        $this->queueName = $vals['queueName'];
      }
      if (isset($vals['queueQuota'])) {
        $this->queueQuota = $vals['queueQuota'];
      }
    }
  }

  public function getName() {
    return 'SetQueueQuotaRequest';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->queueName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->queueQuota = new \EMQ\Queue\QueueQuota();
            $xfer += $this->queueQuota->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('SetQueueQuotaRequest');
    if ($this->queueName !== null) {
      $xfer += $output->writeFieldBegin('queueName', TType::STRING, 1);
      $xfer += $output->writeString($this->queueName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->queueQuota !== null) {
      if (!is_object($this->queueQuota)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('queueQuota', TType::STRUCT, 2);
      $xfer += $this->queueQuota->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class SetQueueQuotaResponse {
  static $_TSPEC;

  /**
   * The queue name;
   * 
   * 
   * @var string
   */
  public $queueName = null;
  /**
   * The queue quota;
   * 
   * 
   * @var \EMQ\Queue\QueueQuota
   */
  public $queueQuota = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'queueName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'queueQuota',
          'type' => TType::STRUCT,
          'class' => '\EMQ\Queue\QueueQuota',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['queueName'])) {
        $this->queueName = $vals['queueName'];
      }
      if (isset($vals['queueQuota'])) {
        $this->queueQuota = $vals['queueQuota'];
      }
    }
  }

  public function getName() {
    return 'SetQueueQuotaResponse';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->queueName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->queueQuota = new \EMQ\Queue\QueueQuota();
            $xfer += $this->queueQuota->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('SetQueueQuotaResponse');
    if ($this->queueName !== null) {
      $xfer += $output->writeFieldBegin('queueName', TType::STRING, 1);
      $xfer += $output->writeString($this->queueName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->queueQuota !== null) {
      if (!is_object($this->queueQuota)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('queueQuota', TType::STRUCT, 2);
      $xfer += $this->queueQuota->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class GetQueueInfoRequest {
  static $_TSPEC;

  /**
   * The queue name;
   * 
   * 
   * @var string
   */
  public $queueName = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'queueName',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['queueName'])) {
        $this->queueName = $vals['queueName'];
      }
    }
  }

  public function getName() {
    return 'GetQueueInfoRequest';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->queueName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('GetQueueInfoRequest');
    if ($this->queueName !== null) {
      $xfer += $output->writeFieldBegin('queueName', TType::STRING, 1);
      $xfer += $output->writeString($this->queueName);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class GetQueueInfoResponse {
  static $_TSPEC;

  /**
   * The queue name;
   * 
   * 
   * @var string
   */
  public $queueName = null;
  /**
   * The queue attribute;
   * 
   * 
   * @var \EMQ\Queue\QueueAttribute
   */
  public $queueAttribute = null;
  /**
   * The queue state;
   * 
   * 
   * @var \EMQ\Queue\QueueState
   */
  public $queueState = null;
  /**
   * The queue quota;
   * 
   * 
   * @var \EMQ\Queue\QueueQuota
   */
  public $queueQuota = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'queueName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'queueAttribute',
          'type' => TType::STRUCT,
          'class' => '\EMQ\Queue\QueueAttribute',
          ),
        3 => array(
          'var' => 'queueState',
          'type' => TType::STRUCT,
          'class' => '\EMQ\Queue\QueueState',
          ),
        4 => array(
          'var' => 'queueQuota',
          'type' => TType::STRUCT,
          'class' => '\EMQ\Queue\QueueQuota',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['queueName'])) {
        $this->queueName = $vals['queueName'];
      }
      if (isset($vals['queueAttribute'])) {
        $this->queueAttribute = $vals['queueAttribute'];
      }
      if (isset($vals['queueState'])) {
        $this->queueState = $vals['queueState'];
      }
      if (isset($vals['queueQuota'])) {
        $this->queueQuota = $vals['queueQuota'];
      }
    }
  }

  public function getName() {
    return 'GetQueueInfoResponse';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->queueName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->queueAttribute = new \EMQ\Queue\QueueAttribute();
            $xfer += $this->queueAttribute->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->queueState = new \EMQ\Queue\QueueState();
            $xfer += $this->queueState->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRUCT) {
            $this->queueQuota = new \EMQ\Queue\QueueQuota();
            $xfer += $this->queueQuota->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('GetQueueInfoResponse');
    if ($this->queueName !== null) {
      $xfer += $output->writeFieldBegin('queueName', TType::STRING, 1);
      $xfer += $output->writeString($this->queueName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->queueAttribute !== null) {
      if (!is_object($this->queueAttribute)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('queueAttribute', TType::STRUCT, 2);
      $xfer += $this->queueAttribute->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->queueState !== null) {
      if (!is_object($this->queueState)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('queueState', TType::STRUCT, 3);
      $xfer += $this->queueState->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->queueQuota !== null) {
      if (!is_object($this->queueQuota)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('queueQuota', TType::STRUCT, 4);
      $xfer += $this->queueQuota->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ListQueueRequest {
  static $_TSPEC;

  /**
   * The queue name prefix;
   * 
   * 
   * @var string
   */
  public $queueNamePrefix = "";

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'queueNamePrefix',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['queueNamePrefix'])) {
        $this->queueNamePrefix = $vals['queueNamePrefix'];
      }
    }
  }

  public function getName() {
    return 'ListQueueRequest';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->queueNamePrefix);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ListQueueRequest');
    if ($this->queueNamePrefix !== null) {
      $xfer += $output->writeFieldBegin('queueNamePrefix', TType::STRING, 1);
      $xfer += $output->writeString($this->queueNamePrefix);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ListQueueResponse {
  static $_TSPEC;

  /**
   * The queueName list with queueNamePrefix;
   * 
   * 
   * @var string[]
   */
  public $queueName = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'queueName',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['queueName'])) {
        $this->queueName = $vals['queueName'];
      }
    }
  }

  public function getName() {
    return 'ListQueueResponse';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::LST) {
            $this->queueName = array();
            $_size9 = 0;
            $_etype12 = 0;
            $xfer += $input->readListBegin($_etype12, $_size9);
            for ($_i13 = 0; $_i13 < $_size9; ++$_i13)
            {
              $elem14 = null;
              $xfer += $input->readString($elem14);
              $this->queueName []= $elem14;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ListQueueResponse');
    if ($this->queueName !== null) {
      if (!is_array($this->queueName)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('queueName', TType::LST, 1);
      {
        $output->writeListBegin(TType::STRING, count($this->queueName));
        {
          foreach ($this->queueName as $iter15)
          {
            $xfer += $output->writeString($iter15);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class SetPermissionRequest {
  static $_TSPEC;

  /**
   * @var string
   */
  public $queueName = null;
  /**
   * @var string
   */
  public $developerId = null;
  /**
   * @var int
   */
  public $permission = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'queueName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'developerId',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'permission',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['queueName'])) {
        $this->queueName = $vals['queueName'];
      }
      if (isset($vals['developerId'])) {
        $this->developerId = $vals['developerId'];
      }
      if (isset($vals['permission'])) {
        $this->permission = $vals['permission'];
      }
    }
  }

  public function getName() {
    return 'SetPermissionRequest';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->queueName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->developerId);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->permission);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('SetPermissionRequest');
    if ($this->queueName !== null) {
      $xfer += $output->writeFieldBegin('queueName', TType::STRING, 1);
      $xfer += $output->writeString($this->queueName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->developerId !== null) {
      $xfer += $output->writeFieldBegin('developerId', TType::STRING, 2);
      $xfer += $output->writeString($this->developerId);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->permission !== null) {
      $xfer += $output->writeFieldBegin('permission', TType::I32, 3);
      $xfer += $output->writeI32($this->permission);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class RevokePermissionRequest {
  static $_TSPEC;

  /**
   * @var string
   */
  public $queueName = null;
  /**
   * @var string
   */
  public $developerId = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'queueName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'developerId',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['queueName'])) {
        $this->queueName = $vals['queueName'];
      }
      if (isset($vals['developerId'])) {
        $this->developerId = $vals['developerId'];
      }
    }
  }

  public function getName() {
    return 'RevokePermissionRequest';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->queueName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->developerId);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('RevokePermissionRequest');
    if ($this->queueName !== null) {
      $xfer += $output->writeFieldBegin('queueName', TType::STRING, 1);
      $xfer += $output->writeString($this->queueName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->developerId !== null) {
      $xfer += $output->writeFieldBegin('developerId', TType::STRING, 2);
      $xfer += $output->writeString($this->developerId);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class QueryPermissionRequest {
  static $_TSPEC;

  /**
   * @var string
   */
  public $queueName = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'queueName',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['queueName'])) {
        $this->queueName = $vals['queueName'];
      }
    }
  }

  public function getName() {
    return 'QueryPermissionRequest';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->queueName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('QueryPermissionRequest');
    if ($this->queueName !== null) {
      $xfer += $output->writeFieldBegin('queueName', TType::STRING, 1);
      $xfer += $output->writeString($this->queueName);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class QueryPermissionResponse {
  static $_TSPEC;

  /**
   * @var int
   */
  public $permission = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'permission',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['permission'])) {
        $this->permission = $vals['permission'];
      }
    }
  }

  public function getName() {
    return 'QueryPermissionResponse';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->permission);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('QueryPermissionResponse');
    if ($this->permission !== null) {
      $xfer += $output->writeFieldBegin('permission', TType::I32, 1);
      $xfer += $output->writeI32($this->permission);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class QueryPermissionForIdRequest {
  static $_TSPEC;

  /**
   * @var string
   */
  public $queueName = null;
  /**
   * @var string
   */
  public $developerId = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'queueName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'developerId',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['queueName'])) {
        $this->queueName = $vals['queueName'];
      }
      if (isset($vals['developerId'])) {
        $this->developerId = $vals['developerId'];
      }
    }
  }

  public function getName() {
    return 'QueryPermissionForIdRequest';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->queueName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->developerId);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('QueryPermissionForIdRequest');
    if ($this->queueName !== null) {
      $xfer += $output->writeFieldBegin('queueName', TType::STRING, 1);
      $xfer += $output->writeString($this->queueName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->developerId !== null) {
      $xfer += $output->writeFieldBegin('developerId', TType::STRING, 2);
      $xfer += $output->writeString($this->developerId);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class QueryPermissionForIdResponse {
  static $_TSPEC;

  /**
   * @var int
   */
  public $permission = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'permission',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['permission'])) {
        $this->permission = $vals['permission'];
      }
    }
  }

  public function getName() {
    return 'QueryPermissionForIdResponse';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->permission);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('QueryPermissionForIdResponse');
    if ($this->permission !== null) {
      $xfer += $output->writeFieldBegin('permission', TType::I32, 1);
      $xfer += $output->writeI32($this->permission);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ListPermissionsRequest {
  static $_TSPEC;

  /**
   * @var string
   */
  public $queueName = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'queueName',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['queueName'])) {
        $this->queueName = $vals['queueName'];
      }
    }
  }

  public function getName() {
    return 'ListPermissionsRequest';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->queueName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ListPermissionsRequest');
    if ($this->queueName !== null) {
      $xfer += $output->writeFieldBegin('queueName', TType::STRING, 1);
      $xfer += $output->writeString($this->queueName);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ListPermissionsResponse {
  static $_TSPEC;

  /**
   * @var array
   */
  public $permissionList = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'permissionList',
          'type' => TType::MAP,
          'ktype' => TType::STRING,
          'vtype' => TType::I32,
          'key' => array(
            'type' => TType::STRING,
          ),
          'val' => array(
            'type' => TType::I32,
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['permissionList'])) {
        $this->permissionList = $vals['permissionList'];
      }
    }
  }

  public function getName() {
    return 'ListPermissionsResponse';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::MAP) {
            $this->permissionList = array();
            $_size16 = 0;
            $_ktype17 = 0;
            $_vtype18 = 0;
            $xfer += $input->readMapBegin($_ktype17, $_vtype18, $_size16);
            for ($_i20 = 0; $_i20 < $_size16; ++$_i20)
            {
              $key21 = '';
              $val22 = 0;
              $xfer += $input->readString($key21);
              $xfer += $input->readI32($val22);
              $this->permissionList[$key21] = $val22;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ListPermissionsResponse');
    if ($this->permissionList !== null) {
      if (!is_array($this->permissionList)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('permissionList', TType::MAP, 1);
      {
        $output->writeMapBegin(TType::STRING, TType::I32, count($this->permissionList));
        {
          foreach ($this->permissionList as $kiter23 => $viter24)
          {
            $xfer += $output->writeString($kiter23);
            $xfer += $output->writeI32($viter24);
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}


