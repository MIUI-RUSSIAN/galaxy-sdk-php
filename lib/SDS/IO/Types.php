<?php
namespace SDS\IO;

/**
 * Autogenerated by Thrift Compiler (0.9.2)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
use Thrift\Base\TBase;
use Thrift\Type\TType;
use Thrift\Type\TMessageType;
use Thrift\Exception\TException;
use Thrift\Exception\TProtocolException;
use Thrift\Protocol\TProtocol;
use Thrift\Protocol\TBinaryProtocolAccelerated;
use Thrift\Exception\TApplicationException;


/**
 * SLFile格式存储类型
 */
final class SLFileType {
  /**
   * Datum Map文件存储格式
   */
  const DATUM_MAP = 1;
  /**
   * 简单RCFile存储形式
   */
  const RC_BASIC = 2;
  static public $__names = array(
    1 => 'DATUM_MAP',
    2 => 'RC_BASIC',
  );
}

/**
 * DATUM_MAP文件格式元信息
 */
class DatumMapMeta {
  static $_TSPEC;

  /**
   * 属性id -> 属性名映射
   * 
   * @var array
   */
  public $keyIdMap = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'keyIdMap',
          'type' => TType::MAP,
          'ktype' => TType::I16,
          'vtype' => TType::STRING,
          'key' => array(
            'type' => TType::I16,
          ),
          'val' => array(
            'type' => TType::STRING,
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['keyIdMap'])) {
        $this->keyIdMap = $vals['keyIdMap'];
      }
    }
  }

  public function getName() {
    return 'DatumMapMeta';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::MAP) {
            $this->keyIdMap = array();
            $_size0 = 0;
            $_ktype1 = 0;
            $_vtype2 = 0;
            $xfer += $input->readMapBegin($_ktype1, $_vtype2, $_size0);
            for ($_i4 = 0; $_i4 < $_size0; ++$_i4)
            {
              $key5 = 0;
              $val6 = '';
              $xfer += $input->readI16($key5);
              $xfer += $input->readString($val6);
              $this->keyIdMap[$key5] = $val6;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('DatumMapMeta');
    if ($this->keyIdMap !== null) {
      if (!is_array($this->keyIdMap)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('keyIdMap', TType::MAP, 1);
      {
        $output->writeMapBegin(TType::I16, TType::STRING, count($this->keyIdMap));
        {
          foreach ($this->keyIdMap as $kiter7 => $viter8)
          {
            $xfer += $output->writeI16($kiter7);
            $xfer += $output->writeString($viter8);
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * RC_BASIC文件格式元信息
 */
class RCBasicMeta {
  static $_TSPEC;

  /**
   * 属性列表
   * 
   * @var string[]
   */
  public $keys = null;
  /**
   * 属性类型
   * 
   * @var array
   */
  public $types = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'keys',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        2 => array(
          'var' => 'types',
          'type' => TType::MAP,
          'ktype' => TType::STRING,
          'vtype' => TType::I32,
          'key' => array(
            'type' => TType::STRING,
          ),
          'val' => array(
            'type' => TType::I32,
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['keys'])) {
        $this->keys = $vals['keys'];
      }
      if (isset($vals['types'])) {
        $this->types = $vals['types'];
      }
    }
  }

  public function getName() {
    return 'RCBasicMeta';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::LST) {
            $this->keys = array();
            $_size9 = 0;
            $_etype12 = 0;
            $xfer += $input->readListBegin($_etype12, $_size9);
            for ($_i13 = 0; $_i13 < $_size9; ++$_i13)
            {
              $elem14 = null;
              $xfer += $input->readString($elem14);
              $this->keys []= $elem14;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::MAP) {
            $this->types = array();
            $_size15 = 0;
            $_ktype16 = 0;
            $_vtype17 = 0;
            $xfer += $input->readMapBegin($_ktype16, $_vtype17, $_size15);
            for ($_i19 = 0; $_i19 < $_size15; ++$_i19)
            {
              $key20 = '';
              $val21 = 0;
              $xfer += $input->readString($key20);
              $xfer += $input->readI32($val21);
              $this->types[$key20] = $val21;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('RCBasicMeta');
    if ($this->keys !== null) {
      if (!is_array($this->keys)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('keys', TType::LST, 1);
      {
        $output->writeListBegin(TType::STRING, count($this->keys));
        {
          foreach ($this->keys as $iter22)
          {
            $xfer += $output->writeString($iter22);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->types !== null) {
      if (!is_array($this->types)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('types', TType::MAP, 2);
      {
        $output->writeMapBegin(TType::STRING, TType::I32, count($this->types));
        {
          foreach ($this->types as $kiter23 => $viter24)
          {
            $xfer += $output->writeString($kiter23);
            $xfer += $output->writeI32($viter24);
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * RC_BASIC Row Group头信息
 */
class RCBasicRowGroupHeader {
  static $_TSPEC;

  /**
   * 行组的记录总数，必须为正整数
   * 
   * @var int
   */
  public $count = null;
  /**
   * 属性列组的相对偏移(相对与头信息结尾，即第一个列组offset总是为0)，
   * 属性的顺序与元信息的属性列表对应
   * 
   * @var int[]
   */
  public $offset = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'count',
          'type' => TType::I32,
          ),
        2 => array(
          'var' => 'offset',
          'type' => TType::LST,
          'etype' => TType::I32,
          'elem' => array(
            'type' => TType::I32,
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['count'])) {
        $this->count = $vals['count'];
      }
      if (isset($vals['offset'])) {
        $this->offset = $vals['offset'];
      }
    }
  }

  public function getName() {
    return 'RCBasicRowGroupHeader';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->count);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::LST) {
            $this->offset = array();
            $_size25 = 0;
            $_etype28 = 0;
            $xfer += $input->readListBegin($_etype28, $_size25);
            for ($_i29 = 0; $_i29 < $_size25; ++$_i29)
            {
              $elem30 = null;
              $xfer += $input->readI32($elem30);
              $this->offset []= $elem30;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('RCBasicRowGroupHeader');
    if ($this->count !== null) {
      $xfer += $output->writeFieldBegin('count', TType::I32, 1);
      $xfer += $output->writeI32($this->count);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->offset !== null) {
      if (!is_array($this->offset)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('offset', TType::LST, 2);
      {
        $output->writeListBegin(TType::I32, count($this->offset));
        {
          foreach ($this->offset as $iter31)
          {
            $xfer += $output->writeI32($iter31);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * SLFile格式存储元信息
 */
class SLFileMeta {
  static $_TSPEC;

  /**
   * @var int
   */
  public $type = null;
  /**
   * @var \SDS\IO\DatumMapMeta
   */
  public $datumMapMeta = null;
  /**
   * @var \SDS\IO\RCBasicMeta
   */
  public $rcBasicMeta = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'type',
          'type' => TType::I32,
          ),
        2 => array(
          'var' => 'datumMapMeta',
          'type' => TType::STRUCT,
          'class' => '\SDS\IO\DatumMapMeta',
          ),
        3 => array(
          'var' => 'rcBasicMeta',
          'type' => TType::STRUCT,
          'class' => '\SDS\IO\RCBasicMeta',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['type'])) {
        $this->type = $vals['type'];
      }
      if (isset($vals['datumMapMeta'])) {
        $this->datumMapMeta = $vals['datumMapMeta'];
      }
      if (isset($vals['rcBasicMeta'])) {
        $this->rcBasicMeta = $vals['rcBasicMeta'];
      }
    }
  }

  public function getName() {
    return 'SLFileMeta';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->type);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->datumMapMeta = new \SDS\IO\DatumMapMeta();
            $xfer += $this->datumMapMeta->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->rcBasicMeta = new \SDS\IO\RCBasicMeta();
            $xfer += $this->rcBasicMeta->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('SLFileMeta');
    if ($this->type !== null) {
      $xfer += $output->writeFieldBegin('type', TType::I32, 1);
      $xfer += $output->writeI32($this->type);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->datumMapMeta !== null) {
      if (!is_object($this->datumMapMeta)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('datumMapMeta', TType::STRUCT, 2);
      $xfer += $this->datumMapMeta->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->rcBasicMeta !== null) {
      if (!is_object($this->rcBasicMeta)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('rcBasicMeta', TType::STRUCT, 3);
      $xfer += $this->rcBasicMeta->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * DATUM_MAP的Datum Map记录定义
 */
class DatumMapRecord {
  static $_TSPEC;

  /**
   * 数据部分
   * 
   * @var array
   */
  public $data = null;
  /**
   * 属性id -> 属性名映射，
   * 只记录当前未知的属性，即如果文件头或者前面记录已经包含某属性，则此处不再包含，
   * 此特性仅用于支持在创建文件时表schema未知的情况
   * 
   * @var array
   */
  public $keyIdMap = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'data',
          'type' => TType::MAP,
          'ktype' => TType::I16,
          'vtype' => TType::STRUCT,
          'key' => array(
            'type' => TType::I16,
          ),
          'val' => array(
            'type' => TType::STRUCT,
            'class' => '\SDS\Table\Datum',
            ),
          ),
        2 => array(
          'var' => 'keyIdMap',
          'type' => TType::MAP,
          'ktype' => TType::I16,
          'vtype' => TType::STRING,
          'key' => array(
            'type' => TType::I16,
          ),
          'val' => array(
            'type' => TType::STRING,
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['data'])) {
        $this->data = $vals['data'];
      }
      if (isset($vals['keyIdMap'])) {
        $this->keyIdMap = $vals['keyIdMap'];
      }
    }
  }

  public function getName() {
    return 'DatumMapRecord';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::MAP) {
            $this->data = array();
            $_size32 = 0;
            $_ktype33 = 0;
            $_vtype34 = 0;
            $xfer += $input->readMapBegin($_ktype33, $_vtype34, $_size32);
            for ($_i36 = 0; $_i36 < $_size32; ++$_i36)
            {
              $key37 = 0;
              $val38 = new \SDS\Table\Datum();
              $xfer += $input->readI16($key37);
              $val38 = new \SDS\Table\Datum();
              $xfer += $val38->read($input);
              $this->data[$key37] = $val38;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::MAP) {
            $this->keyIdMap = array();
            $_size39 = 0;
            $_ktype40 = 0;
            $_vtype41 = 0;
            $xfer += $input->readMapBegin($_ktype40, $_vtype41, $_size39);
            for ($_i43 = 0; $_i43 < $_size39; ++$_i43)
            {
              $key44 = 0;
              $val45 = '';
              $xfer += $input->readI16($key44);
              $xfer += $input->readString($val45);
              $this->keyIdMap[$key44] = $val45;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('DatumMapRecord');
    if ($this->data !== null) {
      if (!is_array($this->data)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('data', TType::MAP, 1);
      {
        $output->writeMapBegin(TType::I16, TType::STRUCT, count($this->data));
        {
          foreach ($this->data as $kiter46 => $viter47)
          {
            $xfer += $output->writeI16($kiter46);
            $xfer += $viter47->write($output);
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->keyIdMap !== null) {
      if (!is_array($this->keyIdMap)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('keyIdMap', TType::MAP, 2);
      {
        $output->writeMapBegin(TType::I16, TType::STRING, count($this->keyIdMap));
        {
          foreach ($this->keyIdMap as $kiter48 => $viter49)
          {
            $xfer += $output->writeI16($kiter48);
            $xfer += $output->writeString($viter49);
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * RC_BASIC的列组定义
 */
class ValueList {
  static $_TSPEC;

  /**
   * 列组数据，仅当所有行对应的列无数据时才为空，而只有部分行对应的列无数据时，其对应值为NullValue
   * 
   * @var \SDS\Table\Value[]
   */
  public $values = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'values',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\SDS\Table\Value',
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['values'])) {
        $this->values = $vals['values'];
      }
    }
  }

  public function getName() {
    return 'ValueList';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::LST) {
            $this->values = array();
            $_size50 = 0;
            $_etype53 = 0;
            $xfer += $input->readListBegin($_etype53, $_size50);
            for ($_i54 = 0; $_i54 < $_size50; ++$_i54)
            {
              $elem55 = null;
              $elem55 = new \SDS\Table\Value();
              $xfer += $elem55->read($input);
              $this->values []= $elem55;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ValueList');
    if ($this->values !== null) {
      if (!is_array($this->values)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('values', TType::LST, 1);
      {
        $output->writeListBegin(TType::STRUCT, count($this->values));
        {
          foreach ($this->values as $iter56)
          {
            $xfer += $iter56->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * Datum Map记录定义，用于序列化原生的SDS表记录(例如，MapReduce中的序列化)
 */
class DatumMap {
  static $_TSPEC;

  /**
   * SDS记录行
   * 
   * @var array
   */
  public $data = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'data',
          'type' => TType::MAP,
          'ktype' => TType::STRING,
          'vtype' => TType::STRUCT,
          'key' => array(
            'type' => TType::STRING,
          ),
          'val' => array(
            'type' => TType::STRUCT,
            'class' => '\SDS\Table\Datum',
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['data'])) {
        $this->data = $vals['data'];
      }
    }
  }

  public function getName() {
    return 'DatumMap';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::MAP) {
            $this->data = array();
            $_size57 = 0;
            $_ktype58 = 0;
            $_vtype59 = 0;
            $xfer += $input->readMapBegin($_ktype58, $_vtype59, $_size57);
            for ($_i61 = 0; $_i61 < $_size57; ++$_i61)
            {
              $key62 = '';
              $val63 = new \SDS\Table\Datum();
              $xfer += $input->readString($key62);
              $val63 = new \SDS\Table\Datum();
              $xfer += $val63->read($input);
              $this->data[$key62] = $val63;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('DatumMap');
    if ($this->data !== null) {
      if (!is_array($this->data)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('data', TType::MAP, 1);
      {
        $output->writeMapBegin(TType::STRING, TType::STRUCT, count($this->data));
        {
          foreach ($this->data as $kiter64 => $viter65)
          {
            $xfer += $output->writeString($kiter64);
            $xfer += $viter65->write($output);
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}


